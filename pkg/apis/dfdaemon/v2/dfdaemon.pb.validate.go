// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pkg/apis/dfdaemon/v2/dfdaemon.proto

package dfdaemon

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common "d7y.io/api/v2/pkg/apis/common/v2"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common.Priority(0)
)

// Validate checks the field values on DownloadTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadTaskRequestMultiError, or nil if none found.
func (m *DownloadTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetDownload() == nil {
		err := DownloadTaskRequestValidationError{
			field:  "Download",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDownload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DownloadTaskRequestValidationError{
					field:  "Download",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DownloadTaskRequestValidationError{
					field:  "Download",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownloadTaskRequestValidationError{
				field:  "Download",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DownloadTaskRequestMultiError(errors)
	}

	return nil
}

// DownloadTaskRequestMultiError is an error wrapping multiple validation
// errors returned by DownloadTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type DownloadTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadTaskRequestMultiError) AllErrors() []error { return m }

// DownloadTaskRequestValidationError is the validation error returned by
// DownloadTaskRequest.Validate if the designated constraints aren't met.
type DownloadTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadTaskRequestValidationError) ErrorName() string {
	return "DownloadTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadTaskRequestValidationError{}

// Validate checks the field values on DownloadTaskStartedResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadTaskStartedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadTaskStartedResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadTaskStartedResponseMultiError, or nil if none found.
func (m *DownloadTaskStartedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadTaskStartedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentLength

	// no validation rules for ResponseHeader

	for idx, item := range m.GetPieces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadTaskStartedResponseValidationError{
						field:  fmt.Sprintf("Pieces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadTaskStartedResponseValidationError{
						field:  fmt.Sprintf("Pieces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadTaskStartedResponseValidationError{
					field:  fmt.Sprintf("Pieces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsFinished

	if m.Range != nil {

		if all {
			switch v := interface{}(m.GetRange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadTaskStartedResponseValidationError{
						field:  "Range",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadTaskStartedResponseValidationError{
						field:  "Range",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadTaskStartedResponseValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DownloadTaskStartedResponseMultiError(errors)
	}

	return nil
}

// DownloadTaskStartedResponseMultiError is an error wrapping multiple
// validation errors returned by DownloadTaskStartedResponse.ValidateAll() if
// the designated constraints aren't met.
type DownloadTaskStartedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadTaskStartedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadTaskStartedResponseMultiError) AllErrors() []error { return m }

// DownloadTaskStartedResponseValidationError is the validation error returned
// by DownloadTaskStartedResponse.Validate if the designated constraints
// aren't met.
type DownloadTaskStartedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadTaskStartedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadTaskStartedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadTaskStartedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadTaskStartedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadTaskStartedResponseValidationError) ErrorName() string {
	return "DownloadTaskStartedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadTaskStartedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadTaskStartedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadTaskStartedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadTaskStartedResponseValidationError{}

// Validate checks the field values on DownloadPieceFinishedResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPieceFinishedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPieceFinishedResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadPieceFinishedResponseMultiError, or nil if none found.
func (m *DownloadPieceFinishedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPieceFinishedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPiece() == nil {
		err := DownloadPieceFinishedResponseValidationError{
			field:  "Piece",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPiece()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DownloadPieceFinishedResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DownloadPieceFinishedResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPiece()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownloadPieceFinishedResponseValidationError{
				field:  "Piece",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DownloadPieceFinishedResponseMultiError(errors)
	}

	return nil
}

// DownloadPieceFinishedResponseMultiError is an error wrapping multiple
// validation errors returned by DownloadPieceFinishedResponse.ValidateAll()
// if the designated constraints aren't met.
type DownloadPieceFinishedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPieceFinishedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPieceFinishedResponseMultiError) AllErrors() []error { return m }

// DownloadPieceFinishedResponseValidationError is the validation error
// returned by DownloadPieceFinishedResponse.Validate if the designated
// constraints aren't met.
type DownloadPieceFinishedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPieceFinishedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPieceFinishedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPieceFinishedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPieceFinishedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPieceFinishedResponseValidationError) ErrorName() string {
	return "DownloadPieceFinishedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPieceFinishedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPieceFinishedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPieceFinishedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPieceFinishedResponseValidationError{}

// Validate checks the field values on DownloadTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadTaskResponseMultiError, or nil if none found.
func (m *DownloadTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadTaskResponseValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadTaskResponseValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerId()) < 1 {
		err := DownloadTaskResponseValidationError{
			field:  "PeerId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofResponsePresent := false
	switch v := m.Response.(type) {
	case *DownloadTaskResponse_DownloadTaskStartedResponse:
		if v == nil {
			err := DownloadTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetDownloadTaskStartedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadTaskResponseValidationError{
						field:  "DownloadTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadTaskResponseValidationError{
						field:  "DownloadTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadTaskStartedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadTaskResponseValidationError{
					field:  "DownloadTaskStartedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DownloadTaskResponse_DownloadPieceFinishedResponse:
		if v == nil {
			err := DownloadTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetDownloadPieceFinishedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadPieceFinishedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadTaskResponseValidationError{
					field:  "DownloadPieceFinishedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofResponsePresent {
		err := DownloadTaskResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DownloadTaskResponseMultiError(errors)
	}

	return nil
}

// DownloadTaskResponseMultiError is an error wrapping multiple validation
// errors returned by DownloadTaskResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadTaskResponseMultiError) AllErrors() []error { return m }

// DownloadTaskResponseValidationError is the validation error returned by
// DownloadTaskResponse.Validate if the designated constraints aren't met.
type DownloadTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadTaskResponseValidationError) ErrorName() string {
	return "DownloadTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadTaskResponseValidationError{}

// Validate checks the field values on SyncPiecesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SyncPiecesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncPiecesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncPiecesRequestMultiError, or nil if none found.
func (m *SyncPiecesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncPiecesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := SyncPiecesRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := SyncPiecesRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetInterestedPieceNumbers()) < 1 {
		err := SyncPiecesRequestValidationError{
			field:  "InterestedPieceNumbers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SyncPiecesRequestMultiError(errors)
	}

	return nil
}

// SyncPiecesRequestMultiError is an error wrapping multiple validation errors
// returned by SyncPiecesRequest.ValidateAll() if the designated constraints
// aren't met.
type SyncPiecesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncPiecesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncPiecesRequestMultiError) AllErrors() []error { return m }

// SyncPiecesRequestValidationError is the validation error returned by
// SyncPiecesRequest.Validate if the designated constraints aren't met.
type SyncPiecesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncPiecesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncPiecesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncPiecesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncPiecesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncPiecesRequestValidationError) ErrorName() string {
	return "SyncPiecesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SyncPiecesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncPiecesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncPiecesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncPiecesRequestValidationError{}

// Validate checks the field values on SyncPiecesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncPiecesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncPiecesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncPiecesResponseMultiError, or nil if none found.
func (m *SyncPiecesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncPiecesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for Offset

	// no validation rules for Length

	if ip := net.ParseIP(m.GetIp()); ip == nil {
		err := SyncPiecesResponseValidationError{
			field:  "Ip",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.TcpPort != nil {

		if m.GetTcpPort() != 0 {

			if val := m.GetTcpPort(); val < 1024 || val >= 65535 {
				err := SyncPiecesResponseValidationError{
					field:  "TcpPort",
					reason: "value must be inside range [1024, 65535)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.QuicPort != nil {

		if m.GetQuicPort() != 0 {

			if val := m.GetQuicPort(); val < 1024 || val >= 65535 {
				err := SyncPiecesResponseValidationError{
					field:  "QuicPort",
					reason: "value must be inside range [1024, 65535)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return SyncPiecesResponseMultiError(errors)
	}

	return nil
}

// SyncPiecesResponseMultiError is an error wrapping multiple validation errors
// returned by SyncPiecesResponse.ValidateAll() if the designated constraints
// aren't met.
type SyncPiecesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncPiecesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncPiecesResponseMultiError) AllErrors() []error { return m }

// SyncPiecesResponseValidationError is the validation error returned by
// SyncPiecesResponse.Validate if the designated constraints aren't met.
type SyncPiecesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncPiecesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncPiecesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncPiecesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncPiecesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncPiecesResponseValidationError) ErrorName() string {
	return "SyncPiecesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SyncPiecesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncPiecesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncPiecesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncPiecesResponseValidationError{}

// Validate checks the field values on DownloadPieceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPieceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPieceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadPieceRequestMultiError, or nil if none found.
func (m *DownloadPieceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPieceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadPieceRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadPieceRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PieceNumber

	if len(errors) > 0 {
		return DownloadPieceRequestMultiError(errors)
	}

	return nil
}

// DownloadPieceRequestMultiError is an error wrapping multiple validation
// errors returned by DownloadPieceRequest.ValidateAll() if the designated
// constraints aren't met.
type DownloadPieceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPieceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPieceRequestMultiError) AllErrors() []error { return m }

// DownloadPieceRequestValidationError is the validation error returned by
// DownloadPieceRequest.Validate if the designated constraints aren't met.
type DownloadPieceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPieceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPieceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPieceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPieceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPieceRequestValidationError) ErrorName() string {
	return "DownloadPieceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPieceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPieceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPieceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPieceRequestValidationError{}

// Validate checks the field values on DownloadPieceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPieceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPieceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadPieceResponseMultiError, or nil if none found.
func (m *DownloadPieceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPieceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPiece() == nil {
		err := DownloadPieceResponseValidationError{
			field:  "Piece",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPiece()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DownloadPieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DownloadPieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPiece()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownloadPieceResponseValidationError{
				field:  "Piece",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Digest != nil {

		if m.GetDigest() != "" {

			if !_DownloadPieceResponse_Digest_Pattern.MatchString(m.GetDigest()) {
				err := DownloadPieceResponseValidationError{
					field:  "Digest",
					reason: "value does not match regex pattern \"^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadPieceResponseMultiError(errors)
	}

	return nil
}

// DownloadPieceResponseMultiError is an error wrapping multiple validation
// errors returned by DownloadPieceResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadPieceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPieceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPieceResponseMultiError) AllErrors() []error { return m }

// DownloadPieceResponseValidationError is the validation error returned by
// DownloadPieceResponse.Validate if the designated constraints aren't met.
type DownloadPieceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPieceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPieceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPieceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPieceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPieceResponseValidationError) ErrorName() string {
	return "DownloadPieceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPieceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPieceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPieceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPieceResponseValidationError{}

var _DownloadPieceResponse_Digest_Pattern = regexp.MustCompile("^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$")

// Validate checks the field values on StatTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StatTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatTaskRequestMultiError, or nil if none found.
func (m *StatTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := StatTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := StatTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return StatTaskRequestMultiError(errors)
	}

	return nil
}

// StatTaskRequestMultiError is an error wrapping multiple validation errors
// returned by StatTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type StatTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatTaskRequestMultiError) AllErrors() []error { return m }

// StatTaskRequestValidationError is the validation error returned by
// StatTaskRequest.Validate if the designated constraints aren't met.
type StatTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatTaskRequestValidationError) ErrorName() string { return "StatTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e StatTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatTaskRequestValidationError{}

// Validate checks the field values on StatLocalTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatLocalTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatLocalTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatLocalTaskRequestMultiError, or nil if none found.
func (m *StatLocalTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatLocalTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := StatLocalTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := StatLocalTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return StatLocalTaskRequestMultiError(errors)
	}

	return nil
}

// StatLocalTaskRequestMultiError is an error wrapping multiple validation
// errors returned by StatLocalTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type StatLocalTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatLocalTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatLocalTaskRequestMultiError) AllErrors() []error { return m }

// StatLocalTaskRequestValidationError is the validation error returned by
// StatLocalTaskRequest.Validate if the designated constraints aren't met.
type StatLocalTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatLocalTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatLocalTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatLocalTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatLocalTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatLocalTaskRequestValidationError) ErrorName() string {
	return "StatLocalTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatLocalTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatLocalTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatLocalTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatLocalTaskRequestValidationError{}

// Validate checks the field values on StatLocalTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatLocalTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatLocalTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatLocalTaskResponseMultiError, or nil if none found.
func (m *StatLocalTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StatLocalTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := StatLocalTaskResponseValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ResponseHeader

	// no validation rules for UploadingCount

	// no validation rules for UploadedCount

	if m.GetCreatedAt() == nil {
		err := StatLocalTaskResponseValidationError{
			field:  "CreatedAt",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetUpdatedAt() == nil {
		err := StatLocalTaskResponseValidationError{
			field:  "UpdatedAt",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.PieceLength != nil {

		if m.GetPieceLength() != 0 {

			if m.GetPieceLength() < 4194304 {
				err := StatLocalTaskResponseValidationError{
					field:  "PieceLength",
					reason: "value must be greater than or equal to 4194304",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.ContentLength != nil {
		// no validation rules for ContentLength
	}

	if m.PrefetchedAt != nil {

		if all {
			switch v := interface{}(m.GetPrefetchedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StatLocalTaskResponseValidationError{
						field:  "PrefetchedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StatLocalTaskResponseValidationError{
						field:  "PrefetchedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrefetchedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StatLocalTaskResponseValidationError{
					field:  "PrefetchedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FailedAt != nil {

		if all {
			switch v := interface{}(m.GetFailedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StatLocalTaskResponseValidationError{
						field:  "FailedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StatLocalTaskResponseValidationError{
						field:  "FailedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFailedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StatLocalTaskResponseValidationError{
					field:  "FailedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.FinishedAt != nil {

		if all {
			switch v := interface{}(m.GetFinishedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StatLocalTaskResponseValidationError{
						field:  "FinishedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StatLocalTaskResponseValidationError{
						field:  "FinishedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFinishedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StatLocalTaskResponseValidationError{
					field:  "FinishedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StatLocalTaskResponseMultiError(errors)
	}

	return nil
}

// StatLocalTaskResponseMultiError is an error wrapping multiple validation
// errors returned by StatLocalTaskResponse.ValidateAll() if the designated
// constraints aren't met.
type StatLocalTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatLocalTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatLocalTaskResponseMultiError) AllErrors() []error { return m }

// StatLocalTaskResponseValidationError is the validation error returned by
// StatLocalTaskResponse.Validate if the designated constraints aren't met.
type StatLocalTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatLocalTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatLocalTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatLocalTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatLocalTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatLocalTaskResponseValidationError) ErrorName() string {
	return "StatLocalTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StatLocalTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatLocalTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatLocalTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatLocalTaskResponseValidationError{}

// Validate checks the field values on ListTaskEntriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTaskEntriesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskEntriesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskEntriesRequestMultiError, or nil if none found.
func (m *ListTaskEntriesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskEntriesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := ListTaskEntriesRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Url

	// no validation rules for RequestHeader

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskEntriesRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskEntriesRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskEntriesRequestValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ObjectStorage != nil {

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskEntriesRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskEntriesRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskEntriesRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Hdfs != nil {

		if all {
			switch v := interface{}(m.GetHdfs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskEntriesRequestValidationError{
						field:  "Hdfs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskEntriesRequestValidationError{
						field:  "Hdfs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHdfs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskEntriesRequestValidationError{
					field:  "Hdfs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := ListTaskEntriesRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return ListTaskEntriesRequestMultiError(errors)
	}

	return nil
}

// ListTaskEntriesRequestMultiError is an error wrapping multiple validation
// errors returned by ListTaskEntriesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListTaskEntriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskEntriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskEntriesRequestMultiError) AllErrors() []error { return m }

// ListTaskEntriesRequestValidationError is the validation error returned by
// ListTaskEntriesRequest.Validate if the designated constraints aren't met.
type ListTaskEntriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskEntriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskEntriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskEntriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskEntriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskEntriesRequestValidationError) ErrorName() string {
	return "ListTaskEntriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTaskEntriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskEntriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskEntriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskEntriesRequestValidationError{}

// Validate checks the field values on ListTaskEntriesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTaskEntriesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTaskEntriesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTaskEntriesResponseMultiError, or nil if none found.
func (m *ListTaskEntriesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTaskEntriesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentLength

	// no validation rules for ResponseHeader

	for idx, item := range m.GetEntries() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTaskEntriesResponseValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTaskEntriesResponseValidationError{
						field:  fmt.Sprintf("Entries[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTaskEntriesResponseValidationError{
					field:  fmt.Sprintf("Entries[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.StatusCode != nil {

		if m.GetStatusCode() != 0 {

			if val := m.GetStatusCode(); val < 100 || val >= 599 {
				err := ListTaskEntriesResponseValidationError{
					field:  "StatusCode",
					reason: "value must be inside range [100, 599)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return ListTaskEntriesResponseMultiError(errors)
	}

	return nil
}

// ListTaskEntriesResponseMultiError is an error wrapping multiple validation
// errors returned by ListTaskEntriesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListTaskEntriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTaskEntriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTaskEntriesResponseMultiError) AllErrors() []error { return m }

// ListTaskEntriesResponseValidationError is the validation error returned by
// ListTaskEntriesResponse.Validate if the designated constraints aren't met.
type ListTaskEntriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTaskEntriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTaskEntriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTaskEntriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTaskEntriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTaskEntriesResponseValidationError) ErrorName() string {
	return "ListTaskEntriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTaskEntriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTaskEntriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTaskEntriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTaskEntriesResponseValidationError{}

// Validate checks the field values on Entry with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Entry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Entry with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EntryMultiError, or nil if none found.
func (m *Entry) ValidateAll() error {
	return m.validate(true)
}

func (m *Entry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	// no validation rules for ContentLength

	// no validation rules for IsDir

	if len(errors) > 0 {
		return EntryMultiError(errors)
	}

	return nil
}

// EntryMultiError is an error wrapping multiple validation errors returned by
// Entry.ValidateAll() if the designated constraints aren't met.
type EntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EntryMultiError) AllErrors() []error { return m }

// EntryValidationError is the validation error returned by Entry.Validate if
// the designated constraints aren't met.
type EntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EntryValidationError) ErrorName() string { return "EntryValidationError" }

// Error satisfies the builtin error interface
func (e EntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EntryValidationError{}

// Validate checks the field values on DeleteTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTaskRequestMultiError, or nil if none found.
func (m *DeleteTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DeleteTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DeleteTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DeleteTaskRequestMultiError(errors)
	}

	return nil
}

// DeleteTaskRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTaskRequestMultiError) AllErrors() []error { return m }

// DeleteTaskRequestValidationError is the validation error returned by
// DeleteTaskRequest.Validate if the designated constraints aren't met.
type DeleteTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTaskRequestValidationError) ErrorName() string {
	return "DeleteTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTaskRequestValidationError{}

// Validate checks the field values on DownloadCacheTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadCacheTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadCacheTaskRequestMultiError, or nil if none found.
func (m *DownloadCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if uri, err := url.Parse(m.GetUrl()); err != nil {
		err = DownloadCacheTaskRequestValidationError{
			field:  "Url",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := DownloadCacheTaskRequestValidationError{
			field:  "Url",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := common.TaskType_name[int32(m.GetType())]; !ok {
		err := DownloadCacheTaskRequestValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := common.Priority_name[int32(m.GetPriority())]; !ok {
		err := DownloadCacheTaskRequestValidationError{
			field:  "Priority",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for RequestHeader

	// no validation rules for DisableBackToSource

	// no validation rules for NeedBackToSource

	// no validation rules for Prefetch

	// no validation rules for IsPrefetch

	// no validation rules for NeedPieceContent

	// no validation rules for Overwrite

	if m.Digest != nil {

		if m.GetDigest() != "" {

			if !_DownloadCacheTaskRequest_Digest_Pattern.MatchString(m.GetDigest()) {
				err := DownloadCacheTaskRequestValidationError{
					field:  "Digest",
					reason: "value does not match regex pattern \"^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Range != nil {

		if all {
			switch v := interface{}(m.GetRange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "Range",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "Range",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskRequestValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Tag != nil {
		// no validation rules for Tag
	}

	if m.Application != nil {
		// no validation rules for Application
	}

	if m.PieceLength != nil {

		if m.GetPieceLength() != 0 {

			if m.GetPieceLength() < 4194304 {
				err := DownloadCacheTaskRequestValidationError{
					field:  "PieceLength",
					reason: "value must be greater than or equal to 4194304",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.OutputPath != nil {

		if m.GetOutputPath() != "" {

			if utf8.RuneCountInString(m.GetOutputPath()) < 1 {
				err := DownloadCacheTaskRequestValidationError{
					field:  "OutputPath",
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskRequestValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ObjectStorage != nil {

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Hdfs != nil {

		if all {
			switch v := interface{}(m.GetHdfs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "Hdfs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskRequestValidationError{
						field:  "Hdfs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHdfs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskRequestValidationError{
					field:  "Hdfs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ContentForCalculatingTaskId != nil {
		// no validation rules for ContentForCalculatingTaskId
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DownloadCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadCacheTaskRequestMultiError(errors)
	}

	return nil
}

// DownloadCacheTaskRequestMultiError is an error wrapping multiple validation
// errors returned by DownloadCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type DownloadCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadCacheTaskRequestMultiError) AllErrors() []error { return m }

// DownloadCacheTaskRequestValidationError is the validation error returned by
// DownloadCacheTaskRequest.Validate if the designated constraints aren't met.
type DownloadCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadCacheTaskRequestValidationError) ErrorName() string {
	return "DownloadCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadCacheTaskRequestValidationError{}

var _DownloadCacheTaskRequest_Digest_Pattern = regexp.MustCompile("^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$")

// Validate checks the field values on DownloadCacheTaskStartedResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DownloadCacheTaskStartedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadCacheTaskStartedResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadCacheTaskStartedResponseMultiError, or nil if none found.
func (m *DownloadCacheTaskStartedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadCacheTaskStartedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentLength

	// no validation rules for ResponseHeader

	for idx, item := range m.GetPieces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskStartedResponseValidationError{
						field:  fmt.Sprintf("Pieces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskStartedResponseValidationError{
						field:  fmt.Sprintf("Pieces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskStartedResponseValidationError{
					field:  fmt.Sprintf("Pieces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IsFinished

	if m.Range != nil {

		if all {
			switch v := interface{}(m.GetRange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskStartedResponseValidationError{
						field:  "Range",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskStartedResponseValidationError{
						field:  "Range",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskStartedResponseValidationError{
					field:  "Range",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DownloadCacheTaskStartedResponseMultiError(errors)
	}

	return nil
}

// DownloadCacheTaskStartedResponseMultiError is an error wrapping multiple
// validation errors returned by
// DownloadCacheTaskStartedResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadCacheTaskStartedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadCacheTaskStartedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadCacheTaskStartedResponseMultiError) AllErrors() []error { return m }

// DownloadCacheTaskStartedResponseValidationError is the validation error
// returned by DownloadCacheTaskStartedResponse.Validate if the designated
// constraints aren't met.
type DownloadCacheTaskStartedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadCacheTaskStartedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadCacheTaskStartedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadCacheTaskStartedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadCacheTaskStartedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadCacheTaskStartedResponseValidationError) ErrorName() string {
	return "DownloadCacheTaskStartedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadCacheTaskStartedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadCacheTaskStartedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadCacheTaskStartedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadCacheTaskStartedResponseValidationError{}

// Validate checks the field values on DownloadCacheTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadCacheTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadCacheTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadCacheTaskResponseMultiError, or nil if none found.
func (m *DownloadCacheTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadCacheTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadCacheTaskResponseValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadCacheTaskResponseValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerId()) < 1 {
		err := DownloadCacheTaskResponseValidationError{
			field:  "PeerId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofResponsePresent := false
	switch v := m.Response.(type) {
	case *DownloadCacheTaskResponse_DownloadCacheTaskStartedResponse:
		if v == nil {
			err := DownloadCacheTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetDownloadCacheTaskStartedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskResponseValidationError{
						field:  "DownloadCacheTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskResponseValidationError{
						field:  "DownloadCacheTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadCacheTaskStartedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskResponseValidationError{
					field:  "DownloadCacheTaskStartedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DownloadCacheTaskResponse_DownloadPieceFinishedResponse:
		if v == nil {
			err := DownloadCacheTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetDownloadPieceFinishedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadCacheTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadCacheTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadPieceFinishedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadCacheTaskResponseValidationError{
					field:  "DownloadPieceFinishedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofResponsePresent {
		err := DownloadCacheTaskResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DownloadCacheTaskResponseMultiError(errors)
	}

	return nil
}

// DownloadCacheTaskResponseMultiError is an error wrapping multiple validation
// errors returned by DownloadCacheTaskResponse.ValidateAll() if the
// designated constraints aren't met.
type DownloadCacheTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadCacheTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadCacheTaskResponseMultiError) AllErrors() []error { return m }

// DownloadCacheTaskResponseValidationError is the validation error returned by
// DownloadCacheTaskResponse.Validate if the designated constraints aren't met.
type DownloadCacheTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadCacheTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadCacheTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadCacheTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadCacheTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadCacheTaskResponseValidationError) ErrorName() string {
	return "DownloadCacheTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadCacheTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadCacheTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadCacheTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadCacheTaskResponseValidationError{}

// Validate checks the field values on SyncCachePiecesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncCachePiecesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncCachePiecesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncCachePiecesRequestMultiError, or nil if none found.
func (m *SyncCachePiecesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncCachePiecesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := SyncCachePiecesRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := SyncCachePiecesRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetInterestedCachePieceNumbers()) < 1 {
		err := SyncCachePiecesRequestValidationError{
			field:  "InterestedCachePieceNumbers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SyncCachePiecesRequestMultiError(errors)
	}

	return nil
}

// SyncCachePiecesRequestMultiError is an error wrapping multiple validation
// errors returned by SyncCachePiecesRequest.ValidateAll() if the designated
// constraints aren't met.
type SyncCachePiecesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncCachePiecesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncCachePiecesRequestMultiError) AllErrors() []error { return m }

// SyncCachePiecesRequestValidationError is the validation error returned by
// SyncCachePiecesRequest.Validate if the designated constraints aren't met.
type SyncCachePiecesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncCachePiecesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncCachePiecesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncCachePiecesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncCachePiecesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncCachePiecesRequestValidationError) ErrorName() string {
	return "SyncCachePiecesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SyncCachePiecesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncCachePiecesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncCachePiecesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncCachePiecesRequestValidationError{}

// Validate checks the field values on SyncCachePiecesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncCachePiecesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncCachePiecesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncCachePiecesResponseMultiError, or nil if none found.
func (m *SyncCachePiecesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncCachePiecesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for Offset

	// no validation rules for Length

	if len(errors) > 0 {
		return SyncCachePiecesResponseMultiError(errors)
	}

	return nil
}

// SyncCachePiecesResponseMultiError is an error wrapping multiple validation
// errors returned by SyncCachePiecesResponse.ValidateAll() if the designated
// constraints aren't met.
type SyncCachePiecesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncCachePiecesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncCachePiecesResponseMultiError) AllErrors() []error { return m }

// SyncCachePiecesResponseValidationError is the validation error returned by
// SyncCachePiecesResponse.Validate if the designated constraints aren't met.
type SyncCachePiecesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncCachePiecesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncCachePiecesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncCachePiecesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncCachePiecesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncCachePiecesResponseValidationError) ErrorName() string {
	return "SyncCachePiecesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SyncCachePiecesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncCachePiecesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncCachePiecesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncCachePiecesResponseValidationError{}

// Validate checks the field values on DownloadCachePieceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadCachePieceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadCachePieceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadCachePieceRequestMultiError, or nil if none found.
func (m *DownloadCachePieceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadCachePieceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadCachePieceRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadCachePieceRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PieceNumber

	if len(errors) > 0 {
		return DownloadCachePieceRequestMultiError(errors)
	}

	return nil
}

// DownloadCachePieceRequestMultiError is an error wrapping multiple validation
// errors returned by DownloadCachePieceRequest.ValidateAll() if the
// designated constraints aren't met.
type DownloadCachePieceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadCachePieceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadCachePieceRequestMultiError) AllErrors() []error { return m }

// DownloadCachePieceRequestValidationError is the validation error returned by
// DownloadCachePieceRequest.Validate if the designated constraints aren't met.
type DownloadCachePieceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadCachePieceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadCachePieceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadCachePieceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadCachePieceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadCachePieceRequestValidationError) ErrorName() string {
	return "DownloadCachePieceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadCachePieceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadCachePieceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadCachePieceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadCachePieceRequestValidationError{}

// Validate checks the field values on DownloadCachePieceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadCachePieceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadCachePieceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadCachePieceResponseMultiError, or nil if none found.
func (m *DownloadCachePieceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadCachePieceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPiece() == nil {
		err := DownloadCachePieceResponseValidationError{
			field:  "Piece",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPiece()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DownloadCachePieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DownloadCachePieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPiece()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownloadCachePieceResponseValidationError{
				field:  "Piece",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Digest != nil {

		if m.GetDigest() != "" {

			if !_DownloadCachePieceResponse_Digest_Pattern.MatchString(m.GetDigest()) {
				err := DownloadCachePieceResponseValidationError{
					field:  "Digest",
					reason: "value does not match regex pattern \"^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadCachePieceResponseMultiError(errors)
	}

	return nil
}

// DownloadCachePieceResponseMultiError is an error wrapping multiple
// validation errors returned by DownloadCachePieceResponse.ValidateAll() if
// the designated constraints aren't met.
type DownloadCachePieceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadCachePieceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadCachePieceResponseMultiError) AllErrors() []error { return m }

// DownloadCachePieceResponseValidationError is the validation error returned
// by DownloadCachePieceResponse.Validate if the designated constraints aren't met.
type DownloadCachePieceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadCachePieceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadCachePieceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadCachePieceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadCachePieceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadCachePieceResponseValidationError) ErrorName() string {
	return "DownloadCachePieceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadCachePieceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadCachePieceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadCachePieceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadCachePieceResponseValidationError{}

var _DownloadCachePieceResponse_Digest_Pattern = regexp.MustCompile("^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$")

// Validate checks the field values on StatCacheTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatCacheTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatCacheTaskRequestMultiError, or nil if none found.
func (m *StatCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := StatCacheTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := StatCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return StatCacheTaskRequestMultiError(errors)
	}

	return nil
}

// StatCacheTaskRequestMultiError is an error wrapping multiple validation
// errors returned by StatCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type StatCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatCacheTaskRequestMultiError) AllErrors() []error { return m }

// StatCacheTaskRequestValidationError is the validation error returned by
// StatCacheTaskRequest.Validate if the designated constraints aren't met.
type StatCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatCacheTaskRequestValidationError) ErrorName() string {
	return "StatCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatCacheTaskRequestValidationError{}

// Validate checks the field values on DeleteCacheTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteCacheTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteCacheTaskRequestMultiError, or nil if none found.
func (m *DeleteCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DeleteCacheTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DeleteCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DeleteCacheTaskRequestMultiError(errors)
	}

	return nil
}

// DeleteCacheTaskRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCacheTaskRequestMultiError) AllErrors() []error { return m }

// DeleteCacheTaskRequestValidationError is the validation error returned by
// DeleteCacheTaskRequest.Validate if the designated constraints aren't met.
type DeleteCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCacheTaskRequestValidationError) ErrorName() string {
	return "DeleteCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCacheTaskRequestValidationError{}

// Validate checks the field values on DownloadPersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPersistentTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadPersistentTaskRequestMultiError, or nil if none found.
func (m *DownloadPersistentTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Persistent

	// no validation rules for NeedPieceContent

	// no validation rules for ForceHardLink

	// no validation rules for Overwrite

	// no validation rules for NeedBackToSource

	if m.ObjectStorageKey != nil {

		if m.GetObjectStorageKey() != "" {

			if utf8.RuneCountInString(m.GetObjectStorageKey()) < 1 {
				err := DownloadPersistentTaskRequestValidationError{
					field:  "ObjectStorageKey",
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.ObjectStorage != nil {

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentTaskRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentTaskRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentTaskRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Tag != nil {
		// no validation rules for Tag
	}

	if m.Application != nil {
		// no validation rules for Application
	}

	if m.OutputPath != nil {

		if m.GetOutputPath() != "" {

			if utf8.RuneCountInString(m.GetOutputPath()) < 1 {
				err := DownloadPersistentTaskRequestValidationError{
					field:  "OutputPath",
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentTaskRequestValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Digest != nil {
		// no validation rules for Digest
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DownloadPersistentTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadPersistentTaskRequestMultiError(errors)
	}

	return nil
}

// DownloadPersistentTaskRequestMultiError is an error wrapping multiple
// validation errors returned by DownloadPersistentTaskRequest.ValidateAll()
// if the designated constraints aren't met.
type DownloadPersistentTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentTaskRequestMultiError) AllErrors() []error { return m }

// DownloadPersistentTaskRequestValidationError is the validation error
// returned by DownloadPersistentTaskRequest.Validate if the designated
// constraints aren't met.
type DownloadPersistentTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentTaskRequestValidationError) ErrorName() string {
	return "DownloadPersistentTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentTaskRequestValidationError{}

// Validate checks the field values on DownloadPersistentTaskStartedResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DownloadPersistentTaskStartedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentTaskStartedResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DownloadPersistentTaskStartedResponseMultiError, or nil if none found.
func (m *DownloadPersistentTaskStartedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentTaskStartedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentLength

	if len(errors) > 0 {
		return DownloadPersistentTaskStartedResponseMultiError(errors)
	}

	return nil
}

// DownloadPersistentTaskStartedResponseMultiError is an error wrapping
// multiple validation errors returned by
// DownloadPersistentTaskStartedResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadPersistentTaskStartedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentTaskStartedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentTaskStartedResponseMultiError) AllErrors() []error { return m }

// DownloadPersistentTaskStartedResponseValidationError is the validation error
// returned by DownloadPersistentTaskStartedResponse.Validate if the
// designated constraints aren't met.
type DownloadPersistentTaskStartedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentTaskStartedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentTaskStartedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentTaskStartedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentTaskStartedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentTaskStartedResponseValidationError) ErrorName() string {
	return "DownloadPersistentTaskStartedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentTaskStartedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentTaskStartedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentTaskStartedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentTaskStartedResponseValidationError{}

// Validate checks the field values on DownloadPersistentTaskResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPersistentTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentTaskResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadPersistentTaskResponseMultiError, or nil if none found.
func (m *DownloadPersistentTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadPersistentTaskResponseValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadPersistentTaskResponseValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerId()) < 1 {
		err := DownloadPersistentTaskResponseValidationError{
			field:  "PeerId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.Response.(type) {
	case *DownloadPersistentTaskResponse_DownloadPersistentTaskStartedResponse:
		if v == nil {
			err := DownloadPersistentTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDownloadPersistentTaskStartedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentTaskResponseValidationError{
						field:  "DownloadPersistentTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentTaskResponseValidationError{
						field:  "DownloadPersistentTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadPersistentTaskStartedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentTaskResponseValidationError{
					field:  "DownloadPersistentTaskStartedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DownloadPersistentTaskResponse_DownloadPieceFinishedResponse:
		if v == nil {
			err := DownloadPersistentTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDownloadPieceFinishedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadPieceFinishedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentTaskResponseValidationError{
					field:  "DownloadPieceFinishedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return DownloadPersistentTaskResponseMultiError(errors)
	}

	return nil
}

// DownloadPersistentTaskResponseMultiError is an error wrapping multiple
// validation errors returned by DownloadPersistentTaskResponse.ValidateAll()
// if the designated constraints aren't met.
type DownloadPersistentTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentTaskResponseMultiError) AllErrors() []error { return m }

// DownloadPersistentTaskResponseValidationError is the validation error
// returned by DownloadPersistentTaskResponse.Validate if the designated
// constraints aren't met.
type DownloadPersistentTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentTaskResponseValidationError) ErrorName() string {
	return "DownloadPersistentTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentTaskResponseValidationError{}

// Validate checks the field values on UploadPersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UploadPersistentTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadPersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UploadPersistentTaskRequestMultiError, or nil if none found.
func (m *UploadPersistentTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadPersistentTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetObjectStorageKey()) < 1 {
		err := UploadPersistentTaskRequestValidationError{
			field:  "ObjectStorageKey",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetObjectStorage() == nil {
		err := UploadPersistentTaskRequestValidationError{
			field:  "ObjectStorage",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetObjectStorage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UploadPersistentTaskRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UploadPersistentTaskRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UploadPersistentTaskRequestValidationError{
				field:  "ObjectStorage",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := UploadPersistentTaskRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PersistentReplicaCount

	if d := m.GetTtl(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = UploadPersistentTaskRequestValidationError{
				field:  "Ttl",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(604800*time.Second + 0*time.Nanosecond)
			gte := time.Duration(60*time.Second + 0*time.Nanosecond)

			if dur < gte || dur > lte {
				err := UploadPersistentTaskRequestValidationError{
					field:  "Ttl",
					reason: "value must be inside range [1m0s, 168h0m0s]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if m.Tag != nil {
		// no validation rules for Tag
	}

	if m.Application != nil {
		// no validation rules for Application
	}

	if m.PieceLength != nil {

		if m.GetPieceLength() != 0 {

			if m.GetPieceLength() < 4194304 {
				err := UploadPersistentTaskRequestValidationError{
					field:  "PieceLength",
					reason: "value must be greater than or equal to 4194304",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UploadPersistentTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UploadPersistentTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UploadPersistentTaskRequestValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := UploadPersistentTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return UploadPersistentTaskRequestMultiError(errors)
	}

	return nil
}

// UploadPersistentTaskRequestMultiError is an error wrapping multiple
// validation errors returned by UploadPersistentTaskRequest.ValidateAll() if
// the designated constraints aren't met.
type UploadPersistentTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadPersistentTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadPersistentTaskRequestMultiError) AllErrors() []error { return m }

// UploadPersistentTaskRequestValidationError is the validation error returned
// by UploadPersistentTaskRequest.Validate if the designated constraints
// aren't met.
type UploadPersistentTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadPersistentTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadPersistentTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadPersistentTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadPersistentTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadPersistentTaskRequestValidationError) ErrorName() string {
	return "UploadPersistentTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UploadPersistentTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadPersistentTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadPersistentTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadPersistentTaskRequestValidationError{}

// Validate checks the field values on UpdatePersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePersistentTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePersistentTaskRequestMultiError, or nil if none found.
func (m *UpdatePersistentTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePersistentTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := UpdatePersistentTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Persistent

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := UpdatePersistentTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return UpdatePersistentTaskRequestMultiError(errors)
	}

	return nil
}

// UpdatePersistentTaskRequestMultiError is an error wrapping multiple
// validation errors returned by UpdatePersistentTaskRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdatePersistentTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePersistentTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePersistentTaskRequestMultiError) AllErrors() []error { return m }

// UpdatePersistentTaskRequestValidationError is the validation error returned
// by UpdatePersistentTaskRequest.Validate if the designated constraints
// aren't met.
type UpdatePersistentTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePersistentTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePersistentTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePersistentTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePersistentTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePersistentTaskRequestValidationError) ErrorName() string {
	return "UpdatePersistentTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePersistentTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePersistentTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePersistentTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePersistentTaskRequestValidationError{}

// Validate checks the field values on StatPersistentTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatPersistentTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatPersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StatPersistentTaskRequestMultiError, or nil if none found.
func (m *StatPersistentTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatPersistentTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := StatPersistentTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := StatPersistentTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return StatPersistentTaskRequestMultiError(errors)
	}

	return nil
}

// StatPersistentTaskRequestMultiError is an error wrapping multiple validation
// errors returned by StatPersistentTaskRequest.ValidateAll() if the
// designated constraints aren't met.
type StatPersistentTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatPersistentTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatPersistentTaskRequestMultiError) AllErrors() []error { return m }

// StatPersistentTaskRequestValidationError is the validation error returned by
// StatPersistentTaskRequest.Validate if the designated constraints aren't met.
type StatPersistentTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatPersistentTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatPersistentTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatPersistentTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatPersistentTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatPersistentTaskRequestValidationError) ErrorName() string {
	return "StatPersistentTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatPersistentTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatPersistentTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatPersistentTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatPersistentTaskRequestValidationError{}

// Validate checks the field values on DeletePersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePersistentTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePersistentTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePersistentTaskRequestMultiError, or nil if none found.
func (m *DeletePersistentTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePersistentTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DeletePersistentTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DeletePersistentTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DeletePersistentTaskRequestMultiError(errors)
	}

	return nil
}

// DeletePersistentTaskRequestMultiError is an error wrapping multiple
// validation errors returned by DeletePersistentTaskRequest.ValidateAll() if
// the designated constraints aren't met.
type DeletePersistentTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePersistentTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePersistentTaskRequestMultiError) AllErrors() []error { return m }

// DeletePersistentTaskRequestValidationError is the validation error returned
// by DeletePersistentTaskRequest.Validate if the designated constraints
// aren't met.
type DeletePersistentTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePersistentTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePersistentTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePersistentTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePersistentTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePersistentTaskRequestValidationError) ErrorName() string {
	return "DeletePersistentTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePersistentTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePersistentTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePersistentTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePersistentTaskRequestValidationError{}

// Validate checks the field values on SyncPersistentPiecesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncPersistentPiecesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncPersistentPiecesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncPersistentPiecesRequestMultiError, or nil if none found.
func (m *SyncPersistentPiecesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncPersistentPiecesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := SyncPersistentPiecesRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := SyncPersistentPiecesRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetInterestedPieceNumbers()) < 1 {
		err := SyncPersistentPiecesRequestValidationError{
			field:  "InterestedPieceNumbers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SyncPersistentPiecesRequestMultiError(errors)
	}

	return nil
}

// SyncPersistentPiecesRequestMultiError is an error wrapping multiple
// validation errors returned by SyncPersistentPiecesRequest.ValidateAll() if
// the designated constraints aren't met.
type SyncPersistentPiecesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncPersistentPiecesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncPersistentPiecesRequestMultiError) AllErrors() []error { return m }

// SyncPersistentPiecesRequestValidationError is the validation error returned
// by SyncPersistentPiecesRequest.Validate if the designated constraints
// aren't met.
type SyncPersistentPiecesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncPersistentPiecesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncPersistentPiecesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncPersistentPiecesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncPersistentPiecesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncPersistentPiecesRequestValidationError) ErrorName() string {
	return "SyncPersistentPiecesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SyncPersistentPiecesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncPersistentPiecesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncPersistentPiecesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncPersistentPiecesRequestValidationError{}

// Validate checks the field values on SyncPersistentPiecesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SyncPersistentPiecesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncPersistentPiecesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncPersistentPiecesResponseMultiError, or nil if none found.
func (m *SyncPersistentPiecesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncPersistentPiecesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for Offset

	// no validation rules for Length

	if ip := net.ParseIP(m.GetIp()); ip == nil {
		err := SyncPersistentPiecesResponseValidationError{
			field:  "Ip",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.TcpPort != nil {

		if m.GetTcpPort() != 0 {

			if val := m.GetTcpPort(); val < 1024 || val >= 65535 {
				err := SyncPersistentPiecesResponseValidationError{
					field:  "TcpPort",
					reason: "value must be inside range [1024, 65535)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.QuicPort != nil {

		if m.GetQuicPort() != 0 {

			if val := m.GetQuicPort(); val < 1024 || val >= 65535 {
				err := SyncPersistentPiecesResponseValidationError{
					field:  "QuicPort",
					reason: "value must be inside range [1024, 65535)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return SyncPersistentPiecesResponseMultiError(errors)
	}

	return nil
}

// SyncPersistentPiecesResponseMultiError is an error wrapping multiple
// validation errors returned by SyncPersistentPiecesResponse.ValidateAll() if
// the designated constraints aren't met.
type SyncPersistentPiecesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncPersistentPiecesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncPersistentPiecesResponseMultiError) AllErrors() []error { return m }

// SyncPersistentPiecesResponseValidationError is the validation error returned
// by SyncPersistentPiecesResponse.Validate if the designated constraints
// aren't met.
type SyncPersistentPiecesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncPersistentPiecesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncPersistentPiecesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncPersistentPiecesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncPersistentPiecesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncPersistentPiecesResponseValidationError) ErrorName() string {
	return "SyncPersistentPiecesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SyncPersistentPiecesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncPersistentPiecesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncPersistentPiecesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncPersistentPiecesResponseValidationError{}

// Validate checks the field values on DownloadPersistentPieceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPersistentPieceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentPieceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadPersistentPieceRequestMultiError, or nil if none found.
func (m *DownloadPersistentPieceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentPieceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadPersistentPieceRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadPersistentPieceRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PieceNumber

	if len(errors) > 0 {
		return DownloadPersistentPieceRequestMultiError(errors)
	}

	return nil
}

// DownloadPersistentPieceRequestMultiError is an error wrapping multiple
// validation errors returned by DownloadPersistentPieceRequest.ValidateAll()
// if the designated constraints aren't met.
type DownloadPersistentPieceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentPieceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentPieceRequestMultiError) AllErrors() []error { return m }

// DownloadPersistentPieceRequestValidationError is the validation error
// returned by DownloadPersistentPieceRequest.Validate if the designated
// constraints aren't met.
type DownloadPersistentPieceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentPieceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentPieceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentPieceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentPieceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentPieceRequestValidationError) ErrorName() string {
	return "DownloadPersistentPieceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentPieceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentPieceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentPieceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentPieceRequestValidationError{}

// Validate checks the field values on DownloadPersistentPieceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DownloadPersistentPieceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentPieceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DownloadPersistentPieceResponseMultiError, or nil if none found.
func (m *DownloadPersistentPieceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentPieceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPiece() == nil {
		err := DownloadPersistentPieceResponseValidationError{
			field:  "Piece",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPiece()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DownloadPersistentPieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DownloadPersistentPieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPiece()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownloadPersistentPieceResponseValidationError{
				field:  "Piece",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Digest != nil {

		if m.GetDigest() != "" {

			if !_DownloadPersistentPieceResponse_Digest_Pattern.MatchString(m.GetDigest()) {
				err := DownloadPersistentPieceResponseValidationError{
					field:  "Digest",
					reason: "value does not match regex pattern \"^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadPersistentPieceResponseMultiError(errors)
	}

	return nil
}

// DownloadPersistentPieceResponseMultiError is an error wrapping multiple
// validation errors returned by DownloadPersistentPieceResponse.ValidateAll()
// if the designated constraints aren't met.
type DownloadPersistentPieceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentPieceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentPieceResponseMultiError) AllErrors() []error { return m }

// DownloadPersistentPieceResponseValidationError is the validation error
// returned by DownloadPersistentPieceResponse.Validate if the designated
// constraints aren't met.
type DownloadPersistentPieceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentPieceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentPieceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentPieceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentPieceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentPieceResponseValidationError) ErrorName() string {
	return "DownloadPersistentPieceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentPieceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentPieceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentPieceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentPieceResponseValidationError{}

var _DownloadPersistentPieceResponse_Digest_Pattern = regexp.MustCompile("^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$")

// Validate checks the field values on DownloadPersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DownloadPersistentCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentCacheTaskRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DownloadPersistentCacheTaskRequestMultiError, or nil if none found.
func (m *DownloadPersistentCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadPersistentCacheTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Persistent

	// no validation rules for NeedPieceContent

	// no validation rules for ForceHardLink

	// no validation rules for Overwrite

	if m.Tag != nil {
		// no validation rules for Tag
	}

	if m.Application != nil {
		// no validation rules for Application
	}

	if m.OutputPath != nil {

		if m.GetOutputPath() != "" {

			if utf8.RuneCountInString(m.GetOutputPath()) < 1 {
				err := DownloadPersistentCacheTaskRequestValidationError{
					field:  "OutputPath",
					reason: "value length must be at least 1 runes",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentCacheTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentCacheTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentCacheTaskRequestValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Digest != nil {
		// no validation rules for Digest
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DownloadPersistentCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadPersistentCacheTaskRequestMultiError(errors)
	}

	return nil
}

// DownloadPersistentCacheTaskRequestMultiError is an error wrapping multiple
// validation errors returned by
// DownloadPersistentCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type DownloadPersistentCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentCacheTaskRequestMultiError) AllErrors() []error { return m }

// DownloadPersistentCacheTaskRequestValidationError is the validation error
// returned by DownloadPersistentCacheTaskRequest.Validate if the designated
// constraints aren't met.
type DownloadPersistentCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentCacheTaskRequestValidationError) ErrorName() string {
	return "DownloadPersistentCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentCacheTaskRequestValidationError{}

// Validate checks the field values on
// DownloadPersistentCacheTaskStartedResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DownloadPersistentCacheTaskStartedResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DownloadPersistentCacheTaskStartedResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DownloadPersistentCacheTaskStartedResponseMultiError, or nil if none found.
func (m *DownloadPersistentCacheTaskStartedResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentCacheTaskStartedResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ContentLength

	if len(errors) > 0 {
		return DownloadPersistentCacheTaskStartedResponseMultiError(errors)
	}

	return nil
}

// DownloadPersistentCacheTaskStartedResponseMultiError is an error wrapping
// multiple validation errors returned by
// DownloadPersistentCacheTaskStartedResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadPersistentCacheTaskStartedResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentCacheTaskStartedResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentCacheTaskStartedResponseMultiError) AllErrors() []error { return m }

// DownloadPersistentCacheTaskStartedResponseValidationError is the validation
// error returned by DownloadPersistentCacheTaskStartedResponse.Validate if
// the designated constraints aren't met.
type DownloadPersistentCacheTaskStartedResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentCacheTaskStartedResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentCacheTaskStartedResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentCacheTaskStartedResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentCacheTaskStartedResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentCacheTaskStartedResponseValidationError) ErrorName() string {
	return "DownloadPersistentCacheTaskStartedResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentCacheTaskStartedResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentCacheTaskStartedResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentCacheTaskStartedResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentCacheTaskStartedResponseValidationError{}

// Validate checks the field values on DownloadPersistentCacheTaskResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DownloadPersistentCacheTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentCacheTaskResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DownloadPersistentCacheTaskResponseMultiError, or nil if none found.
func (m *DownloadPersistentCacheTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentCacheTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadPersistentCacheTaskResponseValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadPersistentCacheTaskResponseValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerId()) < 1 {
		err := DownloadPersistentCacheTaskResponseValidationError{
			field:  "PeerId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofResponsePresent := false
	switch v := m.Response.(type) {
	case *DownloadPersistentCacheTaskResponse_DownloadPersistentCacheTaskStartedResponse:
		if v == nil {
			err := DownloadPersistentCacheTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetDownloadPersistentCacheTaskStartedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentCacheTaskResponseValidationError{
						field:  "DownloadPersistentCacheTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentCacheTaskResponseValidationError{
						field:  "DownloadPersistentCacheTaskStartedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadPersistentCacheTaskStartedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentCacheTaskResponseValidationError{
					field:  "DownloadPersistentCacheTaskStartedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *DownloadPersistentCacheTaskResponse_DownloadPieceFinishedResponse:
		if v == nil {
			err := DownloadPersistentCacheTaskResponseValidationError{
				field:  "Response",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofResponsePresent = true

		if all {
			switch v := interface{}(m.GetDownloadPieceFinishedResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DownloadPersistentCacheTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DownloadPersistentCacheTaskResponseValidationError{
						field:  "DownloadPieceFinishedResponse",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDownloadPieceFinishedResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DownloadPersistentCacheTaskResponseValidationError{
					field:  "DownloadPieceFinishedResponse",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofResponsePresent {
		err := DownloadPersistentCacheTaskResponseValidationError{
			field:  "Response",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DownloadPersistentCacheTaskResponseMultiError(errors)
	}

	return nil
}

// DownloadPersistentCacheTaskResponseMultiError is an error wrapping multiple
// validation errors returned by
// DownloadPersistentCacheTaskResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadPersistentCacheTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentCacheTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentCacheTaskResponseMultiError) AllErrors() []error { return m }

// DownloadPersistentCacheTaskResponseValidationError is the validation error
// returned by DownloadPersistentCacheTaskResponse.Validate if the designated
// constraints aren't met.
type DownloadPersistentCacheTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentCacheTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentCacheTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentCacheTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentCacheTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentCacheTaskResponseValidationError) ErrorName() string {
	return "DownloadPersistentCacheTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentCacheTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentCacheTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentCacheTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentCacheTaskResponseValidationError{}

// Validate checks the field values on UploadPersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UploadPersistentCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UploadPersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UploadPersistentCacheTaskRequestMultiError, or nil if none found.
func (m *UploadPersistentCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UploadPersistentCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPath()) < 1 {
		err := UploadPersistentCacheTaskRequestValidationError{
			field:  "Path",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetPersistentReplicaCount(); val < 1 || val > 5 {
		err := UploadPersistentCacheTaskRequestValidationError{
			field:  "PersistentReplicaCount",
			reason: "value must be inside range [1, 5]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if d := m.GetTtl(); d != nil {
		dur, err := d.AsDuration(), d.CheckValid()
		if err != nil {
			err = UploadPersistentCacheTaskRequestValidationError{
				field:  "Ttl",
				reason: "value is not a valid duration",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {

			lte := time.Duration(604800*time.Second + 0*time.Nanosecond)
			gte := time.Duration(60*time.Second + 0*time.Nanosecond)

			if dur < gte || dur > lte {
				err := UploadPersistentCacheTaskRequestValidationError{
					field:  "Ttl",
					reason: "value must be inside range [1m0s, 168h0m0s]",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}
	}

	if m.ContentForCalculatingTaskId != nil {
		// no validation rules for ContentForCalculatingTaskId
	}

	if m.Tag != nil {
		// no validation rules for Tag
	}

	if m.Application != nil {
		// no validation rules for Application
	}

	if m.PieceLength != nil {

		if m.GetPieceLength() != 0 {

			if m.GetPieceLength() < 4194304 {
				err := UploadPersistentCacheTaskRequestValidationError{
					field:  "PieceLength",
					reason: "value must be greater than or equal to 4194304",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.Timeout != nil {

		if all {
			switch v := interface{}(m.GetTimeout()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UploadPersistentCacheTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UploadPersistentCacheTaskRequestValidationError{
						field:  "Timeout",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTimeout()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UploadPersistentCacheTaskRequestValidationError{
					field:  "Timeout",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := UploadPersistentCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return UploadPersistentCacheTaskRequestMultiError(errors)
	}

	return nil
}

// UploadPersistentCacheTaskRequestMultiError is an error wrapping multiple
// validation errors returned by
// UploadPersistentCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type UploadPersistentCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UploadPersistentCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UploadPersistentCacheTaskRequestMultiError) AllErrors() []error { return m }

// UploadPersistentCacheTaskRequestValidationError is the validation error
// returned by UploadPersistentCacheTaskRequest.Validate if the designated
// constraints aren't met.
type UploadPersistentCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UploadPersistentCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UploadPersistentCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UploadPersistentCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UploadPersistentCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UploadPersistentCacheTaskRequestValidationError) ErrorName() string {
	return "UploadPersistentCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UploadPersistentCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUploadPersistentCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UploadPersistentCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UploadPersistentCacheTaskRequestValidationError{}

// Validate checks the field values on UpdatePersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdatePersistentCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdatePersistentCacheTaskRequestMultiError, or nil if none found.
func (m *UpdatePersistentCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePersistentCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := UpdatePersistentCacheTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Persistent

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := UpdatePersistentCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return UpdatePersistentCacheTaskRequestMultiError(errors)
	}

	return nil
}

// UpdatePersistentCacheTaskRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdatePersistentCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePersistentCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePersistentCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePersistentCacheTaskRequestMultiError) AllErrors() []error { return m }

// UpdatePersistentCacheTaskRequestValidationError is the validation error
// returned by UpdatePersistentCacheTaskRequest.Validate if the designated
// constraints aren't met.
type UpdatePersistentCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePersistentCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePersistentCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePersistentCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePersistentCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePersistentCacheTaskRequestValidationError) ErrorName() string {
	return "UpdatePersistentCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePersistentCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePersistentCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePersistentCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePersistentCacheTaskRequestValidationError{}

// Validate checks the field values on StatPersistentCacheTaskRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StatPersistentCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatPersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StatPersistentCacheTaskRequestMultiError, or nil if none found.
func (m *StatPersistentCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatPersistentCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := StatPersistentCacheTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := StatPersistentCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return StatPersistentCacheTaskRequestMultiError(errors)
	}

	return nil
}

// StatPersistentCacheTaskRequestMultiError is an error wrapping multiple
// validation errors returned by StatPersistentCacheTaskRequest.ValidateAll()
// if the designated constraints aren't met.
type StatPersistentCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatPersistentCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatPersistentCacheTaskRequestMultiError) AllErrors() []error { return m }

// StatPersistentCacheTaskRequestValidationError is the validation error
// returned by StatPersistentCacheTaskRequest.Validate if the designated
// constraints aren't met.
type StatPersistentCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatPersistentCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatPersistentCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatPersistentCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatPersistentCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatPersistentCacheTaskRequestValidationError) ErrorName() string {
	return "StatPersistentCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StatPersistentCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatPersistentCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatPersistentCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatPersistentCacheTaskRequestValidationError{}

// Validate checks the field values on DeletePersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DeletePersistentCacheTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePersistentCacheTaskRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// DeletePersistentCacheTaskRequestMultiError, or nil if none found.
func (m *DeletePersistentCacheTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePersistentCacheTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DeletePersistentCacheTaskRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.RemoteIp != nil {

		if m.GetRemoteIp() != "" {

			if ip := net.ParseIP(m.GetRemoteIp()); ip == nil {
				err := DeletePersistentCacheTaskRequestValidationError{
					field:  "RemoteIp",
					reason: "value must be a valid IP address",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DeletePersistentCacheTaskRequestMultiError(errors)
	}

	return nil
}

// DeletePersistentCacheTaskRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeletePersistentCacheTaskRequest.ValidateAll() if the designated
// constraints aren't met.
type DeletePersistentCacheTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePersistentCacheTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePersistentCacheTaskRequestMultiError) AllErrors() []error { return m }

// DeletePersistentCacheTaskRequestValidationError is the validation error
// returned by DeletePersistentCacheTaskRequest.Validate if the designated
// constraints aren't met.
type DeletePersistentCacheTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePersistentCacheTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePersistentCacheTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePersistentCacheTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePersistentCacheTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePersistentCacheTaskRequestValidationError) ErrorName() string {
	return "DeletePersistentCacheTaskRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePersistentCacheTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePersistentCacheTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePersistentCacheTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePersistentCacheTaskRequestValidationError{}

// Validate checks the field values on SyncPersistentCachePiecesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SyncPersistentCachePiecesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncPersistentCachePiecesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// SyncPersistentCachePiecesRequestMultiError, or nil if none found.
func (m *SyncPersistentCachePiecesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncPersistentCachePiecesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := SyncPersistentCachePiecesRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := SyncPersistentCachePiecesRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetInterestedPieceNumbers()) < 1 {
		err := SyncPersistentCachePiecesRequestValidationError{
			field:  "InterestedPieceNumbers",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SyncPersistentCachePiecesRequestMultiError(errors)
	}

	return nil
}

// SyncPersistentCachePiecesRequestMultiError is an error wrapping multiple
// validation errors returned by
// SyncPersistentCachePiecesRequest.ValidateAll() if the designated
// constraints aren't met.
type SyncPersistentCachePiecesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncPersistentCachePiecesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncPersistentCachePiecesRequestMultiError) AllErrors() []error { return m }

// SyncPersistentCachePiecesRequestValidationError is the validation error
// returned by SyncPersistentCachePiecesRequest.Validate if the designated
// constraints aren't met.
type SyncPersistentCachePiecesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncPersistentCachePiecesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncPersistentCachePiecesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncPersistentCachePiecesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncPersistentCachePiecesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncPersistentCachePiecesRequestValidationError) ErrorName() string {
	return "SyncPersistentCachePiecesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SyncPersistentCachePiecesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncPersistentCachePiecesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncPersistentCachePiecesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncPersistentCachePiecesRequestValidationError{}

// Validate checks the field values on SyncPersistentCachePiecesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *SyncPersistentCachePiecesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncPersistentCachePiecesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// SyncPersistentCachePiecesResponseMultiError, or nil if none found.
func (m *SyncPersistentCachePiecesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncPersistentCachePiecesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for Offset

	// no validation rules for Length

	if ip := net.ParseIP(m.GetIp()); ip == nil {
		err := SyncPersistentCachePiecesResponseValidationError{
			field:  "Ip",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.TcpPort != nil {

		if m.GetTcpPort() != 0 {

			if val := m.GetTcpPort(); val < 1024 || val >= 65535 {
				err := SyncPersistentCachePiecesResponseValidationError{
					field:  "TcpPort",
					reason: "value must be inside range [1024, 65535)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if m.QuicPort != nil {

		if m.GetQuicPort() != 0 {

			if val := m.GetQuicPort(); val < 1024 || val >= 65535 {
				err := SyncPersistentCachePiecesResponseValidationError{
					field:  "QuicPort",
					reason: "value must be inside range [1024, 65535)",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return SyncPersistentCachePiecesResponseMultiError(errors)
	}

	return nil
}

// SyncPersistentCachePiecesResponseMultiError is an error wrapping multiple
// validation errors returned by
// SyncPersistentCachePiecesResponse.ValidateAll() if the designated
// constraints aren't met.
type SyncPersistentCachePiecesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncPersistentCachePiecesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncPersistentCachePiecesResponseMultiError) AllErrors() []error { return m }

// SyncPersistentCachePiecesResponseValidationError is the validation error
// returned by SyncPersistentCachePiecesResponse.Validate if the designated
// constraints aren't met.
type SyncPersistentCachePiecesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncPersistentCachePiecesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncPersistentCachePiecesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncPersistentCachePiecesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncPersistentCachePiecesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncPersistentCachePiecesResponseValidationError) ErrorName() string {
	return "SyncPersistentCachePiecesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SyncPersistentCachePiecesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncPersistentCachePiecesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncPersistentCachePiecesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncPersistentCachePiecesResponseValidationError{}

// Validate checks the field values on DownloadPersistentCachePieceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *DownloadPersistentCachePieceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentCachePieceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DownloadPersistentCachePieceRequestMultiError, or nil if none found.
func (m *DownloadPersistentCachePieceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentCachePieceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := DownloadPersistentCachePieceRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskId()) < 1 {
		err := DownloadPersistentCachePieceRequestValidationError{
			field:  "TaskId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PieceNumber

	if len(errors) > 0 {
		return DownloadPersistentCachePieceRequestMultiError(errors)
	}

	return nil
}

// DownloadPersistentCachePieceRequestMultiError is an error wrapping multiple
// validation errors returned by
// DownloadPersistentCachePieceRequest.ValidateAll() if the designated
// constraints aren't met.
type DownloadPersistentCachePieceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentCachePieceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentCachePieceRequestMultiError) AllErrors() []error { return m }

// DownloadPersistentCachePieceRequestValidationError is the validation error
// returned by DownloadPersistentCachePieceRequest.Validate if the designated
// constraints aren't met.
type DownloadPersistentCachePieceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentCachePieceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentCachePieceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentCachePieceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentCachePieceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentCachePieceRequestValidationError) ErrorName() string {
	return "DownloadPersistentCachePieceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentCachePieceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentCachePieceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentCachePieceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentCachePieceRequestValidationError{}

// Validate checks the field values on DownloadPersistentCachePieceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DownloadPersistentCachePieceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadPersistentCachePieceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// DownloadPersistentCachePieceResponseMultiError, or nil if none found.
func (m *DownloadPersistentCachePieceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadPersistentCachePieceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPiece() == nil {
		err := DownloadPersistentCachePieceResponseValidationError{
			field:  "Piece",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPiece()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DownloadPersistentCachePieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DownloadPersistentCachePieceResponseValidationError{
					field:  "Piece",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPiece()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DownloadPersistentCachePieceResponseValidationError{
				field:  "Piece",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Digest != nil {

		if m.GetDigest() != "" {

			if !_DownloadPersistentCachePieceResponse_Digest_Pattern.MatchString(m.GetDigest()) {
				err := DownloadPersistentCachePieceResponseValidationError{
					field:  "Digest",
					reason: "value does not match regex pattern \"^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$\"",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return DownloadPersistentCachePieceResponseMultiError(errors)
	}

	return nil
}

// DownloadPersistentCachePieceResponseMultiError is an error wrapping multiple
// validation errors returned by
// DownloadPersistentCachePieceResponse.ValidateAll() if the designated
// constraints aren't met.
type DownloadPersistentCachePieceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadPersistentCachePieceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadPersistentCachePieceResponseMultiError) AllErrors() []error { return m }

// DownloadPersistentCachePieceResponseValidationError is the validation error
// returned by DownloadPersistentCachePieceResponse.Validate if the designated
// constraints aren't met.
type DownloadPersistentCachePieceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadPersistentCachePieceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadPersistentCachePieceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadPersistentCachePieceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadPersistentCachePieceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadPersistentCachePieceResponseValidationError) ErrorName() string {
	return "DownloadPersistentCachePieceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadPersistentCachePieceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadPersistentCachePieceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadPersistentCachePieceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadPersistentCachePieceResponseValidationError{}

var _DownloadPersistentCachePieceResponse_Digest_Pattern = regexp.MustCompile("^(md5:[a-fA-F0-9]{32}|sha1:[a-fA-F0-9]{40}|sha256:[a-fA-F0-9]{64}|sha512:[a-fA-F0-9]{128}|blake3:[a-fA-F0-9]{64}|crc32:[a-fA-F0-9]+)$")

// Validate checks the field values on SyncHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SyncHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SyncHostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SyncHostRequestMultiError, or nil if none found.
func (m *SyncHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SyncHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetHostId()) < 1 {
		err := SyncHostRequestValidationError{
			field:  "HostId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPeerId()) < 1 {
		err := SyncHostRequestValidationError{
			field:  "PeerId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SyncHostRequestMultiError(errors)
	}

	return nil
}

// SyncHostRequestMultiError is an error wrapping multiple validation errors
// returned by SyncHostRequest.ValidateAll() if the designated constraints
// aren't met.
type SyncHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SyncHostRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SyncHostRequestMultiError) AllErrors() []error { return m }

// SyncHostRequestValidationError is the validation error returned by
// SyncHostRequest.Validate if the designated constraints aren't met.
type SyncHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SyncHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SyncHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SyncHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SyncHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SyncHostRequestValidationError) ErrorName() string { return "SyncHostRequestValidationError" }

// Error satisfies the builtin error interface
func (e SyncHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSyncHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SyncHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SyncHostRequestValidationError{}

// Validate checks the field values on IBVerbsQueuePairEndpoint with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *IBVerbsQueuePairEndpoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IBVerbsQueuePairEndpoint with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IBVerbsQueuePairEndpointMultiError, or nil if none found.
func (m *IBVerbsQueuePairEndpoint) ValidateAll() error {
	return m.validate(true)
}

func (m *IBVerbsQueuePairEndpoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Num

	// no validation rules for Lid

	if len(m.GetGid()) != 16 {
		err := IBVerbsQueuePairEndpointValidationError{
			field:  "Gid",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IBVerbsQueuePairEndpointMultiError(errors)
	}

	return nil
}

// IBVerbsQueuePairEndpointMultiError is an error wrapping multiple validation
// errors returned by IBVerbsQueuePairEndpoint.ValidateAll() if the designated
// constraints aren't met.
type IBVerbsQueuePairEndpointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IBVerbsQueuePairEndpointMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IBVerbsQueuePairEndpointMultiError) AllErrors() []error { return m }

// IBVerbsQueuePairEndpointValidationError is the validation error returned by
// IBVerbsQueuePairEndpoint.Validate if the designated constraints aren't met.
type IBVerbsQueuePairEndpointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IBVerbsQueuePairEndpointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IBVerbsQueuePairEndpointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IBVerbsQueuePairEndpointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IBVerbsQueuePairEndpointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IBVerbsQueuePairEndpointValidationError) ErrorName() string {
	return "IBVerbsQueuePairEndpointValidationError"
}

// Error satisfies the builtin error interface
func (e IBVerbsQueuePairEndpointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIBVerbsQueuePairEndpoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IBVerbsQueuePairEndpointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IBVerbsQueuePairEndpointValidationError{}

// Validate checks the field values on ExchangeIBVerbsQueuePairEndpointRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExchangeIBVerbsQueuePairEndpointRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExchangeIBVerbsQueuePairEndpointRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ExchangeIBVerbsQueuePairEndpointRequestMultiError, or nil if none found.
func (m *ExchangeIBVerbsQueuePairEndpointRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeIBVerbsQueuePairEndpointRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetEndpoint() == nil {
		err := ExchangeIBVerbsQueuePairEndpointRequestValidationError{
			field:  "Endpoint",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExchangeIBVerbsQueuePairEndpointRequestValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExchangeIBVerbsQueuePairEndpointRequestValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExchangeIBVerbsQueuePairEndpointRequestValidationError{
				field:  "Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExchangeIBVerbsQueuePairEndpointRequestMultiError(errors)
	}

	return nil
}

// ExchangeIBVerbsQueuePairEndpointRequestMultiError is an error wrapping
// multiple validation errors returned by
// ExchangeIBVerbsQueuePairEndpointRequest.ValidateAll() if the designated
// constraints aren't met.
type ExchangeIBVerbsQueuePairEndpointRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeIBVerbsQueuePairEndpointRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeIBVerbsQueuePairEndpointRequestMultiError) AllErrors() []error { return m }

// ExchangeIBVerbsQueuePairEndpointRequestValidationError is the validation
// error returned by ExchangeIBVerbsQueuePairEndpointRequest.Validate if the
// designated constraints aren't met.
type ExchangeIBVerbsQueuePairEndpointRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeIBVerbsQueuePairEndpointRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeIBVerbsQueuePairEndpointRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeIBVerbsQueuePairEndpointRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeIBVerbsQueuePairEndpointRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeIBVerbsQueuePairEndpointRequestValidationError) ErrorName() string {
	return "ExchangeIBVerbsQueuePairEndpointRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeIBVerbsQueuePairEndpointRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeIBVerbsQueuePairEndpointRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeIBVerbsQueuePairEndpointRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeIBVerbsQueuePairEndpointRequestValidationError{}

// Validate checks the field values on ExchangeIBVerbsQueuePairEndpointResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ExchangeIBVerbsQueuePairEndpointResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ExchangeIBVerbsQueuePairEndpointResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ExchangeIBVerbsQueuePairEndpointResponseMultiError, or nil if none found.
func (m *ExchangeIBVerbsQueuePairEndpointResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExchangeIBVerbsQueuePairEndpointResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetEndpoint() == nil {
		err := ExchangeIBVerbsQueuePairEndpointResponseValidationError{
			field:  "Endpoint",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExchangeIBVerbsQueuePairEndpointResponseValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExchangeIBVerbsQueuePairEndpointResponseValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExchangeIBVerbsQueuePairEndpointResponseValidationError{
				field:  "Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExchangeIBVerbsQueuePairEndpointResponseMultiError(errors)
	}

	return nil
}

// ExchangeIBVerbsQueuePairEndpointResponseMultiError is an error wrapping
// multiple validation errors returned by
// ExchangeIBVerbsQueuePairEndpointResponse.ValidateAll() if the designated
// constraints aren't met.
type ExchangeIBVerbsQueuePairEndpointResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExchangeIBVerbsQueuePairEndpointResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExchangeIBVerbsQueuePairEndpointResponseMultiError) AllErrors() []error { return m }

// ExchangeIBVerbsQueuePairEndpointResponseValidationError is the validation
// error returned by ExchangeIBVerbsQueuePairEndpointResponse.Validate if the
// designated constraints aren't met.
type ExchangeIBVerbsQueuePairEndpointResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExchangeIBVerbsQueuePairEndpointResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExchangeIBVerbsQueuePairEndpointResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExchangeIBVerbsQueuePairEndpointResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExchangeIBVerbsQueuePairEndpointResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExchangeIBVerbsQueuePairEndpointResponseValidationError) ErrorName() string {
	return "ExchangeIBVerbsQueuePairEndpointResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExchangeIBVerbsQueuePairEndpointResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExchangeIBVerbsQueuePairEndpointResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExchangeIBVerbsQueuePairEndpointResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExchangeIBVerbsQueuePairEndpointResponseValidationError{}
