// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pkg/apis/inference/v1/model_config.proto

package inference

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ModelRateLimiter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModelRateLimiter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelRateLimiter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelRateLimiterMultiError, or nil if none found.
func (m *ModelRateLimiter) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelRateLimiter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetResources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelRateLimiterValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelRateLimiterValidationError{
						field:  fmt.Sprintf("Resources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelRateLimiterValidationError{
					field:  fmt.Sprintf("Resources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Priority

	if len(errors) > 0 {
		return ModelRateLimiterMultiError(errors)
	}

	return nil
}

// ModelRateLimiterMultiError is an error wrapping multiple validation errors
// returned by ModelRateLimiter.ValidateAll() if the designated constraints
// aren't met.
type ModelRateLimiterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelRateLimiterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelRateLimiterMultiError) AllErrors() []error { return m }

// ModelRateLimiterValidationError is the validation error returned by
// ModelRateLimiter.Validate if the designated constraints aren't met.
type ModelRateLimiterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelRateLimiterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelRateLimiterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelRateLimiterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelRateLimiterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelRateLimiterValidationError) ErrorName() string { return "ModelRateLimiterValidationError" }

// Error satisfies the builtin error interface
func (e ModelRateLimiterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelRateLimiter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelRateLimiterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelRateLimiterValidationError{}

// Validate checks the field values on ModelInstanceGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelInstanceGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelInstanceGroup with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelInstanceGroupMultiError, or nil if none found.
func (m *ModelInstanceGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelInstanceGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Kind

	// no validation rules for Count

	if all {
		switch v := interface{}(m.GetRateLimiter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelInstanceGroupValidationError{
					field:  "RateLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelInstanceGroupValidationError{
					field:  "RateLimiter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRateLimiter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelInstanceGroupValidationError{
				field:  "RateLimiter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSecondaryDevices() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelInstanceGroupValidationError{
						field:  fmt.Sprintf("SecondaryDevices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelInstanceGroupValidationError{
						field:  fmt.Sprintf("SecondaryDevices[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelInstanceGroupValidationError{
					field:  fmt.Sprintf("SecondaryDevices[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Passive

	// no validation rules for HostPolicy

	if len(errors) > 0 {
		return ModelInstanceGroupMultiError(errors)
	}

	return nil
}

// ModelInstanceGroupMultiError is an error wrapping multiple validation errors
// returned by ModelInstanceGroup.ValidateAll() if the designated constraints
// aren't met.
type ModelInstanceGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelInstanceGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelInstanceGroupMultiError) AllErrors() []error { return m }

// ModelInstanceGroupValidationError is the validation error returned by
// ModelInstanceGroup.Validate if the designated constraints aren't met.
type ModelInstanceGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelInstanceGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelInstanceGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelInstanceGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelInstanceGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelInstanceGroupValidationError) ErrorName() string {
	return "ModelInstanceGroupValidationError"
}

// Error satisfies the builtin error interface
func (e ModelInstanceGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelInstanceGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelInstanceGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelInstanceGroupValidationError{}

// Validate checks the field values on ModelTensorReshape with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelTensorReshape) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelTensorReshape with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelTensorReshapeMultiError, or nil if none found.
func (m *ModelTensorReshape) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelTensorReshape) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ModelTensorReshapeMultiError(errors)
	}

	return nil
}

// ModelTensorReshapeMultiError is an error wrapping multiple validation errors
// returned by ModelTensorReshape.ValidateAll() if the designated constraints
// aren't met.
type ModelTensorReshapeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelTensorReshapeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelTensorReshapeMultiError) AllErrors() []error { return m }

// ModelTensorReshapeValidationError is the validation error returned by
// ModelTensorReshape.Validate if the designated constraints aren't met.
type ModelTensorReshapeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelTensorReshapeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelTensorReshapeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelTensorReshapeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelTensorReshapeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelTensorReshapeValidationError) ErrorName() string {
	return "ModelTensorReshapeValidationError"
}

// Error satisfies the builtin error interface
func (e ModelTensorReshapeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelTensorReshape.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelTensorReshapeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelTensorReshapeValidationError{}

// Validate checks the field values on ModelInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelInputMultiError, or
// nil if none found.
func (m *ModelInput) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DataType

	// no validation rules for Format

	if all {
		switch v := interface{}(m.GetReshape()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelInputValidationError{
					field:  "Reshape",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelInputValidationError{
					field:  "Reshape",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReshape()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelInputValidationError{
				field:  "Reshape",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsShapeTensor

	// no validation rules for AllowRaggedBatch

	// no validation rules for Optional

	if len(errors) > 0 {
		return ModelInputMultiError(errors)
	}

	return nil
}

// ModelInputMultiError is an error wrapping multiple validation errors
// returned by ModelInput.ValidateAll() if the designated constraints aren't met.
type ModelInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelInputMultiError) AllErrors() []error { return m }

// ModelInputValidationError is the validation error returned by
// ModelInput.Validate if the designated constraints aren't met.
type ModelInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelInputValidationError) ErrorName() string { return "ModelInputValidationError" }

// Error satisfies the builtin error interface
func (e ModelInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelInputValidationError{}

// Validate checks the field values on ModelOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelOutputMultiError, or
// nil if none found.
func (m *ModelOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for DataType

	if all {
		switch v := interface{}(m.GetReshape()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOutputValidationError{
					field:  "Reshape",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOutputValidationError{
					field:  "Reshape",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReshape()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOutputValidationError{
				field:  "Reshape",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LabelFilename

	// no validation rules for IsShapeTensor

	if len(errors) > 0 {
		return ModelOutputMultiError(errors)
	}

	return nil
}

// ModelOutputMultiError is an error wrapping multiple validation errors
// returned by ModelOutput.ValidateAll() if the designated constraints aren't met.
type ModelOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOutputMultiError) AllErrors() []error { return m }

// ModelOutputValidationError is the validation error returned by
// ModelOutput.Validate if the designated constraints aren't met.
type ModelOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOutputValidationError) ErrorName() string { return "ModelOutputValidationError" }

// Error satisfies the builtin error interface
func (e ModelOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOutputValidationError{}

// Validate checks the field values on BatchInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BatchInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BatchInputMultiError, or
// nil if none found.
func (m *BatchInput) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for DataType

	if len(errors) > 0 {
		return BatchInputMultiError(errors)
	}

	return nil
}

// BatchInputMultiError is an error wrapping multiple validation errors
// returned by BatchInput.ValidateAll() if the designated constraints aren't met.
type BatchInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchInputMultiError) AllErrors() []error { return m }

// BatchInputValidationError is the validation error returned by
// BatchInput.Validate if the designated constraints aren't met.
type BatchInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchInputValidationError) ErrorName() string { return "BatchInputValidationError" }

// Error satisfies the builtin error interface
func (e BatchInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchInputValidationError{}

// Validate checks the field values on BatchOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BatchOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BatchOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BatchOutputMultiError, or
// nil if none found.
func (m *BatchOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *BatchOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	if len(errors) > 0 {
		return BatchOutputMultiError(errors)
	}

	return nil
}

// BatchOutputMultiError is an error wrapping multiple validation errors
// returned by BatchOutput.ValidateAll() if the designated constraints aren't met.
type BatchOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchOutputMultiError) AllErrors() []error { return m }

// BatchOutputValidationError is the validation error returned by
// BatchOutput.Validate if the designated constraints aren't met.
type BatchOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchOutputValidationError) ErrorName() string { return "BatchOutputValidationError" }

// Error satisfies the builtin error interface
func (e BatchOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchOutputValidationError{}

// Validate checks the field values on ModelVersionPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelVersionPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelVersionPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelVersionPolicyMultiError, or nil if none found.
func (m *ModelVersionPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelVersionPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.PolicyChoice.(type) {
	case *ModelVersionPolicy_Latest_:
		if v == nil {
			err := ModelVersionPolicyValidationError{
				field:  "PolicyChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLatest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelVersionPolicyValidationError{
						field:  "Latest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelVersionPolicyValidationError{
						field:  "Latest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLatest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelVersionPolicyValidationError{
					field:  "Latest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModelVersionPolicy_All_:
		if v == nil {
			err := ModelVersionPolicyValidationError{
				field:  "PolicyChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAll()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelVersionPolicyValidationError{
						field:  "All",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelVersionPolicyValidationError{
						field:  "All",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAll()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelVersionPolicyValidationError{
					field:  "All",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModelVersionPolicy_Specific_:
		if v == nil {
			err := ModelVersionPolicyValidationError{
				field:  "PolicyChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSpecific()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelVersionPolicyValidationError{
						field:  "Specific",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelVersionPolicyValidationError{
						field:  "Specific",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSpecific()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelVersionPolicyValidationError{
					field:  "Specific",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ModelVersionPolicyMultiError(errors)
	}

	return nil
}

// ModelVersionPolicyMultiError is an error wrapping multiple validation errors
// returned by ModelVersionPolicy.ValidateAll() if the designated constraints
// aren't met.
type ModelVersionPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelVersionPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelVersionPolicyMultiError) AllErrors() []error { return m }

// ModelVersionPolicyValidationError is the validation error returned by
// ModelVersionPolicy.Validate if the designated constraints aren't met.
type ModelVersionPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelVersionPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelVersionPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelVersionPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelVersionPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelVersionPolicyValidationError) ErrorName() string {
	return "ModelVersionPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e ModelVersionPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelVersionPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelVersionPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelVersionPolicyValidationError{}

// Validate checks the field values on ModelOptimizationPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelOptimizationPolicy with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelOptimizationPolicyMultiError, or nil if none found.
func (m *ModelOptimizationPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGraph()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "Graph",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "Graph",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGraph()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOptimizationPolicyValidationError{
				field:  "Graph",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Priority

	if all {
		switch v := interface{}(m.GetCuda()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "Cuda",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "Cuda",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCuda()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOptimizationPolicyValidationError{
				field:  "Cuda",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExecutionAccelerators()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "ExecutionAccelerators",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "ExecutionAccelerators",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionAccelerators()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOptimizationPolicyValidationError{
				field:  "ExecutionAccelerators",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInputPinnedMemory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "InputPinnedMemory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "InputPinnedMemory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInputPinnedMemory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOptimizationPolicyValidationError{
				field:  "InputPinnedMemory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutputPinnedMemory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "OutputPinnedMemory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOptimizationPolicyValidationError{
					field:  "OutputPinnedMemory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputPinnedMemory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOptimizationPolicyValidationError{
				field:  "OutputPinnedMemory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for GatherKernelBufferThreshold

	// no validation rules for EagerBatching

	if len(errors) > 0 {
		return ModelOptimizationPolicyMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicyMultiError is an error wrapping multiple validation
// errors returned by ModelOptimizationPolicy.ValidateAll() if the designated
// constraints aren't met.
type ModelOptimizationPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicyMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicyValidationError is the validation error returned by
// ModelOptimizationPolicy.Validate if the designated constraints aren't met.
type ModelOptimizationPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOptimizationPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicyValidationError) ErrorName() string {
	return "ModelOptimizationPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicyValidationError{}

// Validate checks the field values on ModelQueuePolicy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModelQueuePolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelQueuePolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelQueuePolicyMultiError, or nil if none found.
func (m *ModelQueuePolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelQueuePolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TimeoutAction

	// no validation rules for DefaultTimeoutMicroseconds

	// no validation rules for AllowTimeoutOverride

	// no validation rules for MaxQueueSize

	if len(errors) > 0 {
		return ModelQueuePolicyMultiError(errors)
	}

	return nil
}

// ModelQueuePolicyMultiError is an error wrapping multiple validation errors
// returned by ModelQueuePolicy.ValidateAll() if the designated constraints
// aren't met.
type ModelQueuePolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelQueuePolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelQueuePolicyMultiError) AllErrors() []error { return m }

// ModelQueuePolicyValidationError is the validation error returned by
// ModelQueuePolicy.Validate if the designated constraints aren't met.
type ModelQueuePolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelQueuePolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelQueuePolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelQueuePolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelQueuePolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelQueuePolicyValidationError) ErrorName() string { return "ModelQueuePolicyValidationError" }

// Error satisfies the builtin error interface
func (e ModelQueuePolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelQueuePolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelQueuePolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelQueuePolicyValidationError{}

// Validate checks the field values on ModelDynamicBatching with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelDynamicBatching) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelDynamicBatching with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelDynamicBatchingMultiError, or nil if none found.
func (m *ModelDynamicBatching) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelDynamicBatching) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxQueueDelayMicroseconds

	// no validation rules for PreserveOrdering

	// no validation rules for PriorityLevels

	// no validation rules for DefaultPriorityLevel

	if all {
		switch v := interface{}(m.GetDefaultQueuePolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelDynamicBatchingValidationError{
					field:  "DefaultQueuePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelDynamicBatchingValidationError{
					field:  "DefaultQueuePolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDefaultQueuePolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelDynamicBatchingValidationError{
				field:  "DefaultQueuePolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]uint64, len(m.GetPriorityQueuePolicy()))
		i := 0
		for key := range m.GetPriorityQueuePolicy() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPriorityQueuePolicy()[key]
			_ = val

			// no validation rules for PriorityQueuePolicy[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ModelDynamicBatchingValidationError{
							field:  fmt.Sprintf("PriorityQueuePolicy[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ModelDynamicBatchingValidationError{
							field:  fmt.Sprintf("PriorityQueuePolicy[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ModelDynamicBatchingValidationError{
						field:  fmt.Sprintf("PriorityQueuePolicy[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ModelDynamicBatchingMultiError(errors)
	}

	return nil
}

// ModelDynamicBatchingMultiError is an error wrapping multiple validation
// errors returned by ModelDynamicBatching.ValidateAll() if the designated
// constraints aren't met.
type ModelDynamicBatchingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelDynamicBatchingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelDynamicBatchingMultiError) AllErrors() []error { return m }

// ModelDynamicBatchingValidationError is the validation error returned by
// ModelDynamicBatching.Validate if the designated constraints aren't met.
type ModelDynamicBatchingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelDynamicBatchingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelDynamicBatchingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelDynamicBatchingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelDynamicBatchingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelDynamicBatchingValidationError) ErrorName() string {
	return "ModelDynamicBatchingValidationError"
}

// Error satisfies the builtin error interface
func (e ModelDynamicBatchingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelDynamicBatching.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelDynamicBatchingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelDynamicBatchingValidationError{}

// Validate checks the field values on ModelSequenceBatching with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelSequenceBatching) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelSequenceBatchingMultiError, or nil if none found.
func (m *ModelSequenceBatching) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxSequenceIdleMicroseconds

	for idx, item := range m.GetControlInput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  fmt.Sprintf("ControlInput[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  fmt.Sprintf("ControlInput[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelSequenceBatchingValidationError{
					field:  fmt.Sprintf("ControlInput[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetState() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  fmt.Sprintf("State[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  fmt.Sprintf("State[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelSequenceBatchingValidationError{
					field:  fmt.Sprintf("State[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.StrategyChoice.(type) {
	case *ModelSequenceBatching_Direct:
		if v == nil {
			err := ModelSequenceBatchingValidationError{
				field:  "StrategyChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDirect()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  "Direct",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  "Direct",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDirect()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelSequenceBatchingValidationError{
					field:  "Direct",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModelSequenceBatching_Oldest:
		if v == nil {
			err := ModelSequenceBatchingValidationError{
				field:  "StrategyChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOldest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  "Oldest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelSequenceBatchingValidationError{
						field:  "Oldest",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOldest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelSequenceBatchingValidationError{
					field:  "Oldest",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ModelSequenceBatchingMultiError(errors)
	}

	return nil
}

// ModelSequenceBatchingMultiError is an error wrapping multiple validation
// errors returned by ModelSequenceBatching.ValidateAll() if the designated
// constraints aren't met.
type ModelSequenceBatchingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatchingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatchingMultiError) AllErrors() []error { return m }

// ModelSequenceBatchingValidationError is the validation error returned by
// ModelSequenceBatching.Validate if the designated constraints aren't met.
type ModelSequenceBatchingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatchingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatchingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatchingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatchingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatchingValidationError) ErrorName() string {
	return "ModelSequenceBatchingValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatchingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatchingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatchingValidationError{}

// Validate checks the field values on ModelEnsembling with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModelEnsembling) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelEnsembling with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelEnsemblingMultiError, or nil if none found.
func (m *ModelEnsembling) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelEnsembling) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStep() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelEnsemblingValidationError{
						field:  fmt.Sprintf("Step[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelEnsemblingValidationError{
						field:  fmt.Sprintf("Step[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelEnsemblingValidationError{
					field:  fmt.Sprintf("Step[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ModelEnsemblingMultiError(errors)
	}

	return nil
}

// ModelEnsemblingMultiError is an error wrapping multiple validation errors
// returned by ModelEnsembling.ValidateAll() if the designated constraints
// aren't met.
type ModelEnsemblingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelEnsemblingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelEnsemblingMultiError) AllErrors() []error { return m }

// ModelEnsemblingValidationError is the validation error returned by
// ModelEnsembling.Validate if the designated constraints aren't met.
type ModelEnsemblingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelEnsemblingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelEnsemblingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelEnsemblingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelEnsemblingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelEnsemblingValidationError) ErrorName() string { return "ModelEnsemblingValidationError" }

// Error satisfies the builtin error interface
func (e ModelEnsemblingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelEnsembling.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelEnsemblingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelEnsemblingValidationError{}

// Validate checks the field values on ModelParameter with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelParameter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelParameter with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelParameterMultiError,
// or nil if none found.
func (m *ModelParameter) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelParameter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StringValue

	if len(errors) > 0 {
		return ModelParameterMultiError(errors)
	}

	return nil
}

// ModelParameterMultiError is an error wrapping multiple validation errors
// returned by ModelParameter.ValidateAll() if the designated constraints
// aren't met.
type ModelParameterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelParameterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelParameterMultiError) AllErrors() []error { return m }

// ModelParameterValidationError is the validation error returned by
// ModelParameter.Validate if the designated constraints aren't met.
type ModelParameterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelParameterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelParameterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelParameterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelParameterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelParameterValidationError) ErrorName() string { return "ModelParameterValidationError" }

// Error satisfies the builtin error interface
func (e ModelParameterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelParameter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelParameterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelParameterValidationError{}

// Validate checks the field values on ModelWarmup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelWarmup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelWarmup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelWarmupMultiError, or
// nil if none found.
func (m *ModelWarmup) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelWarmup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for BatchSize

	{
		sorted_keys := make([]string, len(m.GetInputs()))
		i := 0
		for key := range m.GetInputs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetInputs()[key]
			_ = val

			// no validation rules for Inputs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ModelWarmupValidationError{
							field:  fmt.Sprintf("Inputs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ModelWarmupValidationError{
							field:  fmt.Sprintf("Inputs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ModelWarmupValidationError{
						field:  fmt.Sprintf("Inputs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for Count

	if len(errors) > 0 {
		return ModelWarmupMultiError(errors)
	}

	return nil
}

// ModelWarmupMultiError is an error wrapping multiple validation errors
// returned by ModelWarmup.ValidateAll() if the designated constraints aren't met.
type ModelWarmupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelWarmupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelWarmupMultiError) AllErrors() []error { return m }

// ModelWarmupValidationError is the validation error returned by
// ModelWarmup.Validate if the designated constraints aren't met.
type ModelWarmupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelWarmupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelWarmupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelWarmupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelWarmupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelWarmupValidationError) ErrorName() string { return "ModelWarmupValidationError" }

// Error satisfies the builtin error interface
func (e ModelWarmupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelWarmup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelWarmupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelWarmupValidationError{}

// Validate checks the field values on ModelOperations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModelOperations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelOperations with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelOperationsMultiError, or nil if none found.
func (m *ModelOperations) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOperations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ModelOperationsMultiError(errors)
	}

	return nil
}

// ModelOperationsMultiError is an error wrapping multiple validation errors
// returned by ModelOperations.ValidateAll() if the designated constraints
// aren't met.
type ModelOperationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOperationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOperationsMultiError) AllErrors() []error { return m }

// ModelOperationsValidationError is the validation error returned by
// ModelOperations.Validate if the designated constraints aren't met.
type ModelOperationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOperationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOperationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOperationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOperationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOperationsValidationError) ErrorName() string { return "ModelOperationsValidationError" }

// Error satisfies the builtin error interface
func (e ModelOperationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOperations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOperationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOperationsValidationError{}

// Validate checks the field values on ModelTransactionPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelTransactionPolicy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelTransactionPolicy with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelTransactionPolicyMultiError, or nil if none found.
func (m *ModelTransactionPolicy) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelTransactionPolicy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Decoupled

	if len(errors) > 0 {
		return ModelTransactionPolicyMultiError(errors)
	}

	return nil
}

// ModelTransactionPolicyMultiError is an error wrapping multiple validation
// errors returned by ModelTransactionPolicy.ValidateAll() if the designated
// constraints aren't met.
type ModelTransactionPolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelTransactionPolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelTransactionPolicyMultiError) AllErrors() []error { return m }

// ModelTransactionPolicyValidationError is the validation error returned by
// ModelTransactionPolicy.Validate if the designated constraints aren't met.
type ModelTransactionPolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelTransactionPolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelTransactionPolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelTransactionPolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelTransactionPolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelTransactionPolicyValidationError) ErrorName() string {
	return "ModelTransactionPolicyValidationError"
}

// Error satisfies the builtin error interface
func (e ModelTransactionPolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelTransactionPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelTransactionPolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelTransactionPolicyValidationError{}

// Validate checks the field values on ModelRepositoryAgents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelRepositoryAgents) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelRepositoryAgents with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelRepositoryAgentsMultiError, or nil if none found.
func (m *ModelRepositoryAgents) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelRepositoryAgents) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAgents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelRepositoryAgentsValidationError{
						field:  fmt.Sprintf("Agents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelRepositoryAgentsValidationError{
						field:  fmt.Sprintf("Agents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelRepositoryAgentsValidationError{
					field:  fmt.Sprintf("Agents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ModelRepositoryAgentsMultiError(errors)
	}

	return nil
}

// ModelRepositoryAgentsMultiError is an error wrapping multiple validation
// errors returned by ModelRepositoryAgents.ValidateAll() if the designated
// constraints aren't met.
type ModelRepositoryAgentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelRepositoryAgentsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelRepositoryAgentsMultiError) AllErrors() []error { return m }

// ModelRepositoryAgentsValidationError is the validation error returned by
// ModelRepositoryAgents.Validate if the designated constraints aren't met.
type ModelRepositoryAgentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelRepositoryAgentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelRepositoryAgentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelRepositoryAgentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelRepositoryAgentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelRepositoryAgentsValidationError) ErrorName() string {
	return "ModelRepositoryAgentsValidationError"
}

// Error satisfies the builtin error interface
func (e ModelRepositoryAgentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelRepositoryAgents.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelRepositoryAgentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelRepositoryAgentsValidationError{}

// Validate checks the field values on ModelResponseCache with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelResponseCache) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelResponseCache with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelResponseCacheMultiError, or nil if none found.
func (m *ModelResponseCache) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelResponseCache) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enable

	if len(errors) > 0 {
		return ModelResponseCacheMultiError(errors)
	}

	return nil
}

// ModelResponseCacheMultiError is an error wrapping multiple validation errors
// returned by ModelResponseCache.ValidateAll() if the designated constraints
// aren't met.
type ModelResponseCacheMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelResponseCacheMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelResponseCacheMultiError) AllErrors() []error { return m }

// ModelResponseCacheValidationError is the validation error returned by
// ModelResponseCache.Validate if the designated constraints aren't met.
type ModelResponseCacheValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelResponseCacheValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelResponseCacheValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelResponseCacheValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelResponseCacheValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelResponseCacheValidationError) ErrorName() string {
	return "ModelResponseCacheValidationError"
}

// Error satisfies the builtin error interface
func (e ModelResponseCacheValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelResponseCache.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelResponseCacheValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelResponseCacheValidationError{}

// Validate checks the field values on ModelConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelConfig) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelConfig with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ModelConfigMultiError, or
// nil if none found.
func (m *ModelConfig) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelConfig) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Platform

	// no validation rules for Backend

	if all {
		switch v := interface{}(m.GetVersionPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "VersionPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "VersionPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVersionPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelConfigValidationError{
				field:  "VersionPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MaxBatchSize

	for idx, item := range m.GetInput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("Input[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("Input[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  fmt.Sprintf("Input[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOutput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("Output[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("Output[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  fmt.Sprintf("Output[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBatchInput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("BatchInput[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("BatchInput[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  fmt.Sprintf("BatchInput[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetBatchOutput() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("BatchOutput[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("BatchOutput[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  fmt.Sprintf("BatchOutput[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOptimization()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "Optimization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "Optimization",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptimization()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelConfigValidationError{
				field:  "Optimization",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInstanceGroup() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("InstanceGroup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("InstanceGroup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  fmt.Sprintf("InstanceGroup[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for DefaultModelFilename

	// no validation rules for CcModelFilenames

	// no validation rules for MetricTags

	{
		sorted_keys := make([]string, len(m.GetParameters()))
		i := 0
		for key := range m.GetParameters() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetParameters()[key]
			_ = val

			// no validation rules for Parameters[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ModelConfigValidationError{
							field:  fmt.Sprintf("Parameters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ModelConfigValidationError{
							field:  fmt.Sprintf("Parameters[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ModelConfigValidationError{
						field:  fmt.Sprintf("Parameters[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetModelWarmup() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("ModelWarmup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  fmt.Sprintf("ModelWarmup[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  fmt.Sprintf("ModelWarmup[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetModelOperations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ModelOperations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ModelOperations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModelOperations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelConfigValidationError{
				field:  "ModelOperations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModelTransactionPolicy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ModelTransactionPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ModelTransactionPolicy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModelTransactionPolicy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelConfigValidationError{
				field:  "ModelTransactionPolicy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetModelRepositoryAgents()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ModelRepositoryAgents",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ModelRepositoryAgents",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModelRepositoryAgents()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelConfigValidationError{
				field:  "ModelRepositoryAgents",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponseCache()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ResponseCache",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelConfigValidationError{
					field:  "ResponseCache",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponseCache()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelConfigValidationError{
				field:  "ResponseCache",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.SchedulingChoice.(type) {
	case *ModelConfig_DynamicBatching:
		if v == nil {
			err := ModelConfigValidationError{
				field:  "SchedulingChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDynamicBatching()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  "DynamicBatching",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  "DynamicBatching",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamicBatching()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  "DynamicBatching",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModelConfig_SequenceBatching:
		if v == nil {
			err := ModelConfigValidationError{
				field:  "SchedulingChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSequenceBatching()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  "SequenceBatching",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  "SequenceBatching",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSequenceBatching()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  "SequenceBatching",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModelConfig_EnsembleScheduling:
		if v == nil {
			err := ModelConfigValidationError{
				field:  "SchedulingChoice",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEnsembleScheduling()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  "EnsembleScheduling",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelConfigValidationError{
						field:  "EnsembleScheduling",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnsembleScheduling()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelConfigValidationError{
					field:  "EnsembleScheduling",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ModelConfigMultiError(errors)
	}

	return nil
}

// ModelConfigMultiError is an error wrapping multiple validation errors
// returned by ModelConfig.ValidateAll() if the designated constraints aren't met.
type ModelConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelConfigMultiError) AllErrors() []error { return m }

// ModelConfigValidationError is the validation error returned by
// ModelConfig.Validate if the designated constraints aren't met.
type ModelConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelConfigValidationError) ErrorName() string { return "ModelConfigValidationError" }

// Error satisfies the builtin error interface
func (e ModelConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelConfigValidationError{}

// Validate checks the field values on ModelRateLimiter_Resource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelRateLimiter_Resource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelRateLimiter_Resource with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelRateLimiter_ResourceMultiError, or nil if none found.
func (m *ModelRateLimiter_Resource) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelRateLimiter_Resource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Global

	// no validation rules for Count

	if len(errors) > 0 {
		return ModelRateLimiter_ResourceMultiError(errors)
	}

	return nil
}

// ModelRateLimiter_ResourceMultiError is an error wrapping multiple validation
// errors returned by ModelRateLimiter_Resource.ValidateAll() if the
// designated constraints aren't met.
type ModelRateLimiter_ResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelRateLimiter_ResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelRateLimiter_ResourceMultiError) AllErrors() []error { return m }

// ModelRateLimiter_ResourceValidationError is the validation error returned by
// ModelRateLimiter_Resource.Validate if the designated constraints aren't met.
type ModelRateLimiter_ResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelRateLimiter_ResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelRateLimiter_ResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelRateLimiter_ResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelRateLimiter_ResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelRateLimiter_ResourceValidationError) ErrorName() string {
	return "ModelRateLimiter_ResourceValidationError"
}

// Error satisfies the builtin error interface
func (e ModelRateLimiter_ResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelRateLimiter_Resource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelRateLimiter_ResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelRateLimiter_ResourceValidationError{}

// Validate checks the field values on ModelInstanceGroup_SecondaryDevice with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ModelInstanceGroup_SecondaryDevice) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelInstanceGroup_SecondaryDevice
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ModelInstanceGroup_SecondaryDeviceMultiError, or nil if none found.
func (m *ModelInstanceGroup_SecondaryDevice) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelInstanceGroup_SecondaryDevice) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for DeviceId

	if len(errors) > 0 {
		return ModelInstanceGroup_SecondaryDeviceMultiError(errors)
	}

	return nil
}

// ModelInstanceGroup_SecondaryDeviceMultiError is an error wrapping multiple
// validation errors returned by
// ModelInstanceGroup_SecondaryDevice.ValidateAll() if the designated
// constraints aren't met.
type ModelInstanceGroup_SecondaryDeviceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelInstanceGroup_SecondaryDeviceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelInstanceGroup_SecondaryDeviceMultiError) AllErrors() []error { return m }

// ModelInstanceGroup_SecondaryDeviceValidationError is the validation error
// returned by ModelInstanceGroup_SecondaryDevice.Validate if the designated
// constraints aren't met.
type ModelInstanceGroup_SecondaryDeviceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelInstanceGroup_SecondaryDeviceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelInstanceGroup_SecondaryDeviceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelInstanceGroup_SecondaryDeviceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelInstanceGroup_SecondaryDeviceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelInstanceGroup_SecondaryDeviceValidationError) ErrorName() string {
	return "ModelInstanceGroup_SecondaryDeviceValidationError"
}

// Error satisfies the builtin error interface
func (e ModelInstanceGroup_SecondaryDeviceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelInstanceGroup_SecondaryDevice.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelInstanceGroup_SecondaryDeviceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelInstanceGroup_SecondaryDeviceValidationError{}

// Validate checks the field values on ModelVersionPolicy_Latest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelVersionPolicy_Latest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelVersionPolicy_Latest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelVersionPolicy_LatestMultiError, or nil if none found.
func (m *ModelVersionPolicy_Latest) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelVersionPolicy_Latest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NumVersions

	if len(errors) > 0 {
		return ModelVersionPolicy_LatestMultiError(errors)
	}

	return nil
}

// ModelVersionPolicy_LatestMultiError is an error wrapping multiple validation
// errors returned by ModelVersionPolicy_Latest.ValidateAll() if the
// designated constraints aren't met.
type ModelVersionPolicy_LatestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelVersionPolicy_LatestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelVersionPolicy_LatestMultiError) AllErrors() []error { return m }

// ModelVersionPolicy_LatestValidationError is the validation error returned by
// ModelVersionPolicy_Latest.Validate if the designated constraints aren't met.
type ModelVersionPolicy_LatestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelVersionPolicy_LatestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelVersionPolicy_LatestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelVersionPolicy_LatestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelVersionPolicy_LatestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelVersionPolicy_LatestValidationError) ErrorName() string {
	return "ModelVersionPolicy_LatestValidationError"
}

// Error satisfies the builtin error interface
func (e ModelVersionPolicy_LatestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelVersionPolicy_Latest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelVersionPolicy_LatestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelVersionPolicy_LatestValidationError{}

// Validate checks the field values on ModelVersionPolicy_All with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelVersionPolicy_All) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelVersionPolicy_All with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelVersionPolicy_AllMultiError, or nil if none found.
func (m *ModelVersionPolicy_All) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelVersionPolicy_All) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ModelVersionPolicy_AllMultiError(errors)
	}

	return nil
}

// ModelVersionPolicy_AllMultiError is an error wrapping multiple validation
// errors returned by ModelVersionPolicy_All.ValidateAll() if the designated
// constraints aren't met.
type ModelVersionPolicy_AllMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelVersionPolicy_AllMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelVersionPolicy_AllMultiError) AllErrors() []error { return m }

// ModelVersionPolicy_AllValidationError is the validation error returned by
// ModelVersionPolicy_All.Validate if the designated constraints aren't met.
type ModelVersionPolicy_AllValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelVersionPolicy_AllValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelVersionPolicy_AllValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelVersionPolicy_AllValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelVersionPolicy_AllValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelVersionPolicy_AllValidationError) ErrorName() string {
	return "ModelVersionPolicy_AllValidationError"
}

// Error satisfies the builtin error interface
func (e ModelVersionPolicy_AllValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelVersionPolicy_All.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelVersionPolicy_AllValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelVersionPolicy_AllValidationError{}

// Validate checks the field values on ModelVersionPolicy_Specific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelVersionPolicy_Specific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelVersionPolicy_Specific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelVersionPolicy_SpecificMultiError, or nil if none found.
func (m *ModelVersionPolicy_Specific) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelVersionPolicy_Specific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ModelVersionPolicy_SpecificMultiError(errors)
	}

	return nil
}

// ModelVersionPolicy_SpecificMultiError is an error wrapping multiple
// validation errors returned by ModelVersionPolicy_Specific.ValidateAll() if
// the designated constraints aren't met.
type ModelVersionPolicy_SpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelVersionPolicy_SpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelVersionPolicy_SpecificMultiError) AllErrors() []error { return m }

// ModelVersionPolicy_SpecificValidationError is the validation error returned
// by ModelVersionPolicy_Specific.Validate if the designated constraints
// aren't met.
type ModelVersionPolicy_SpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelVersionPolicy_SpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelVersionPolicy_SpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelVersionPolicy_SpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelVersionPolicy_SpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelVersionPolicy_SpecificValidationError) ErrorName() string {
	return "ModelVersionPolicy_SpecificValidationError"
}

// Error satisfies the builtin error interface
func (e ModelVersionPolicy_SpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelVersionPolicy_Specific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelVersionPolicy_SpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelVersionPolicy_SpecificValidationError{}

// Validate checks the field values on ModelOptimizationPolicy_Graph with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_Graph) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelOptimizationPolicy_Graph with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ModelOptimizationPolicy_GraphMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_Graph) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_Graph) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Level

	if len(errors) > 0 {
		return ModelOptimizationPolicy_GraphMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_GraphMultiError is an error wrapping multiple
// validation errors returned by ModelOptimizationPolicy_Graph.ValidateAll()
// if the designated constraints aren't met.
type ModelOptimizationPolicy_GraphMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_GraphMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_GraphMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_GraphValidationError is the validation error
// returned by ModelOptimizationPolicy_Graph.Validate if the designated
// constraints aren't met.
type ModelOptimizationPolicy_GraphValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_GraphValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicy_GraphValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOptimizationPolicy_GraphValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicy_GraphValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_GraphValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_GraphValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_GraphValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_Graph.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_GraphValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_GraphValidationError{}

// Validate checks the field values on ModelOptimizationPolicy_Cuda with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_Cuda) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelOptimizationPolicy_Cuda with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelOptimizationPolicy_CudaMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_Cuda) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_Cuda) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Graphs

	// no validation rules for BusyWaitEvents

	for idx, item := range m.GetGraphSpec() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelOptimizationPolicy_CudaValidationError{
						field:  fmt.Sprintf("GraphSpec[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelOptimizationPolicy_CudaValidationError{
						field:  fmt.Sprintf("GraphSpec[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelOptimizationPolicy_CudaValidationError{
					field:  fmt.Sprintf("GraphSpec[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for OutputCopyStream

	if len(errors) > 0 {
		return ModelOptimizationPolicy_CudaMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_CudaMultiError is an error wrapping multiple
// validation errors returned by ModelOptimizationPolicy_Cuda.ValidateAll() if
// the designated constraints aren't met.
type ModelOptimizationPolicy_CudaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_CudaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_CudaMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_CudaValidationError is the validation error returned
// by ModelOptimizationPolicy_Cuda.Validate if the designated constraints
// aren't met.
type ModelOptimizationPolicy_CudaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_CudaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicy_CudaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOptimizationPolicy_CudaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicy_CudaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_CudaValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_CudaValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_CudaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_Cuda.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_CudaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_CudaValidationError{}

// Validate checks the field values on
// ModelOptimizationPolicy_ExecutionAccelerators with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_ExecutionAccelerators) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelOptimizationPolicy_ExecutionAccelerators with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ModelOptimizationPolicy_ExecutionAcceleratorsMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_ExecutionAccelerators) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_ExecutionAccelerators) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetGpuExecutionAccelerator() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{
						field:  fmt.Sprintf("GpuExecutionAccelerator[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{
						field:  fmt.Sprintf("GpuExecutionAccelerator[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{
					field:  fmt.Sprintf("GpuExecutionAccelerator[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCpuExecutionAccelerator() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{
						field:  fmt.Sprintf("CpuExecutionAccelerator[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{
						field:  fmt.Sprintf("CpuExecutionAccelerator[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{
					field:  fmt.Sprintf("CpuExecutionAccelerator[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ModelOptimizationPolicy_ExecutionAcceleratorsMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_ExecutionAcceleratorsMultiError is an error wrapping
// multiple validation errors returned by
// ModelOptimizationPolicy_ExecutionAccelerators.ValidateAll() if the
// designated constraints aren't met.
type ModelOptimizationPolicy_ExecutionAcceleratorsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_ExecutionAcceleratorsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_ExecutionAcceleratorsMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_ExecutionAcceleratorsValidationError is the
// validation error returned by
// ModelOptimizationPolicy_ExecutionAccelerators.Validate if the designated
// constraints aren't met.
type ModelOptimizationPolicy_ExecutionAcceleratorsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_ExecutionAcceleratorsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicy_ExecutionAcceleratorsValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ModelOptimizationPolicy_ExecutionAcceleratorsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicy_ExecutionAcceleratorsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_ExecutionAcceleratorsValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_ExecutionAcceleratorsValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_ExecutionAcceleratorsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_ExecutionAccelerators.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_ExecutionAcceleratorsValidationError{}

// Validate checks the field values on
// ModelOptimizationPolicy_PinnedMemoryBuffer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_PinnedMemoryBuffer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelOptimizationPolicy_PinnedMemoryBuffer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ModelOptimizationPolicy_PinnedMemoryBufferMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_PinnedMemoryBuffer) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_PinnedMemoryBuffer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Enable

	if len(errors) > 0 {
		return ModelOptimizationPolicy_PinnedMemoryBufferMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_PinnedMemoryBufferMultiError is an error wrapping
// multiple validation errors returned by
// ModelOptimizationPolicy_PinnedMemoryBuffer.ValidateAll() if the designated
// constraints aren't met.
type ModelOptimizationPolicy_PinnedMemoryBufferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_PinnedMemoryBufferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_PinnedMemoryBufferMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_PinnedMemoryBufferValidationError is the validation
// error returned by ModelOptimizationPolicy_PinnedMemoryBuffer.Validate if
// the designated constraints aren't met.
type ModelOptimizationPolicy_PinnedMemoryBufferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_PinnedMemoryBufferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicy_PinnedMemoryBufferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOptimizationPolicy_PinnedMemoryBufferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicy_PinnedMemoryBufferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_PinnedMemoryBufferValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_PinnedMemoryBufferValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_PinnedMemoryBufferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_PinnedMemoryBuffer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_PinnedMemoryBufferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_PinnedMemoryBufferValidationError{}

// Validate checks the field values on ModelOptimizationPolicy_Cuda_GraphSpec
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ModelOptimizationPolicy_Cuda_GraphSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelOptimizationPolicy_Cuda_GraphSpec with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ModelOptimizationPolicy_Cuda_GraphSpecMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_Cuda_GraphSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_Cuda_GraphSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchSize

	{
		sorted_keys := make([]string, len(m.GetInput()))
		i := 0
		for key := range m.GetInput() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetInput()[key]
			_ = val

			// no validation rules for Input[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ModelOptimizationPolicy_Cuda_GraphSpecValidationError{
							field:  fmt.Sprintf("Input[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ModelOptimizationPolicy_Cuda_GraphSpecValidationError{
							field:  fmt.Sprintf("Input[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ModelOptimizationPolicy_Cuda_GraphSpecValidationError{
						field:  fmt.Sprintf("Input[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetGraphLowerBound()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModelOptimizationPolicy_Cuda_GraphSpecValidationError{
					field:  "GraphLowerBound",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModelOptimizationPolicy_Cuda_GraphSpecValidationError{
					field:  "GraphLowerBound",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGraphLowerBound()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModelOptimizationPolicy_Cuda_GraphSpecValidationError{
				field:  "GraphLowerBound",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ModelOptimizationPolicy_Cuda_GraphSpecMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_Cuda_GraphSpecMultiError is an error wrapping
// multiple validation errors returned by
// ModelOptimizationPolicy_Cuda_GraphSpec.ValidateAll() if the designated
// constraints aren't met.
type ModelOptimizationPolicy_Cuda_GraphSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_Cuda_GraphSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_Cuda_GraphSpecMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_Cuda_GraphSpecValidationError is the validation
// error returned by ModelOptimizationPolicy_Cuda_GraphSpec.Validate if the
// designated constraints aren't met.
type ModelOptimizationPolicy_Cuda_GraphSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_Cuda_GraphSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicy_Cuda_GraphSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOptimizationPolicy_Cuda_GraphSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicy_Cuda_GraphSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_Cuda_GraphSpecValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_Cuda_GraphSpecValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_Cuda_GraphSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_Cuda_GraphSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_Cuda_GraphSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_Cuda_GraphSpecValidationError{}

// Validate checks the field values on
// ModelOptimizationPolicy_Cuda_GraphSpec_Shape with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_Cuda_GraphSpec_Shape) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelOptimizationPolicy_Cuda_GraphSpec_Shape with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ModelOptimizationPolicy_Cuda_GraphSpec_ShapeMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_Cuda_GraphSpec_Shape) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_Cuda_GraphSpec_Shape) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ModelOptimizationPolicy_Cuda_GraphSpec_ShapeMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_Cuda_GraphSpec_ShapeMultiError is an error wrapping
// multiple validation errors returned by
// ModelOptimizationPolicy_Cuda_GraphSpec_Shape.ValidateAll() if the
// designated constraints aren't met.
type ModelOptimizationPolicy_Cuda_GraphSpec_ShapeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_Cuda_GraphSpec_ShapeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_Cuda_GraphSpec_ShapeMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError is the
// validation error returned by
// ModelOptimizationPolicy_Cuda_GraphSpec_Shape.Validate if the designated
// constraints aren't met.
type ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_Cuda_GraphSpec_Shape.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_Cuda_GraphSpec_ShapeValidationError{}

// Validate checks the field values on
// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundMultiError, or nil if none found.
func (m *ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BatchSize

	{
		sorted_keys := make([]string, len(m.GetInput()))
		i := 0
		for key := range m.GetInput() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetInput()[key]
			_ = val

			// no validation rules for Input[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError{
							field:  fmt.Sprintf("Input[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError{
							field:  fmt.Sprintf("Input[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError{
						field:  fmt.Sprintf("Input[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundMultiError is an error
// wrapping multiple validation errors returned by
// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound.ValidateAll() if the
// designated constraints aren't met.
type ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundMultiError) AllErrors() []error { return m }

// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError is the
// validation error returned by
// ModelOptimizationPolicy_Cuda_GraphSpec_LowerBound.Validate if the
// designated constraints aren't met.
type ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_Cuda_GraphSpec_LowerBound.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_Cuda_GraphSpec_LowerBoundValidationError{}

// Validate checks the field values on
// ModelOptimizationPolicy_ExecutionAccelerators_Accelerator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelOptimizationPolicy_ExecutionAccelerators_Accelerator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ModelOptimizationPolicy_ExecutionAccelerators_Accelerator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorMultiError, or nil
// if none found.
func (m *ModelOptimizationPolicy_ExecutionAccelerators_Accelerator) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelOptimizationPolicy_ExecutionAccelerators_Accelerator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Parameters

	if len(errors) > 0 {
		return ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorMultiError(errors)
	}

	return nil
}

// ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorMultiError is an
// error wrapping multiple validation errors returned by
// ModelOptimizationPolicy_ExecutionAccelerators_Accelerator.ValidateAll() if
// the designated constraints aren't met.
type ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorMultiError) AllErrors() []error {
	return m
}

// ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError is
// the validation error returned by
// ModelOptimizationPolicy_ExecutionAccelerators_Accelerator.Validate if the
// designated constraints aren't met.
type ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError) ErrorName() string {
	return "ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError"
}

// Error satisfies the builtin error interface
func (e ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelOptimizationPolicy_ExecutionAccelerators_Accelerator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelOptimizationPolicy_ExecutionAccelerators_AcceleratorValidationError{}

// Validate checks the field values on ModelSequenceBatching_Control with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelSequenceBatching_Control) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching_Control with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ModelSequenceBatching_ControlMultiError, or nil if none found.
func (m *ModelSequenceBatching_Control) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching_Control) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	// no validation rules for DataType

	if len(errors) > 0 {
		return ModelSequenceBatching_ControlMultiError(errors)
	}

	return nil
}

// ModelSequenceBatching_ControlMultiError is an error wrapping multiple
// validation errors returned by ModelSequenceBatching_Control.ValidateAll()
// if the designated constraints aren't met.
type ModelSequenceBatching_ControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatching_ControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatching_ControlMultiError) AllErrors() []error { return m }

// ModelSequenceBatching_ControlValidationError is the validation error
// returned by ModelSequenceBatching_Control.Validate if the designated
// constraints aren't met.
type ModelSequenceBatching_ControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatching_ControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatching_ControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatching_ControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatching_ControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatching_ControlValidationError) ErrorName() string {
	return "ModelSequenceBatching_ControlValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatching_ControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching_Control.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatching_ControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatching_ControlValidationError{}

// Validate checks the field values on ModelSequenceBatching_ControlInput with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ModelSequenceBatching_ControlInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching_ControlInput
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ModelSequenceBatching_ControlInputMultiError, or nil if none found.
func (m *ModelSequenceBatching_ControlInput) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching_ControlInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	for idx, item := range m.GetControl() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelSequenceBatching_ControlInputValidationError{
						field:  fmt.Sprintf("Control[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelSequenceBatching_ControlInputValidationError{
						field:  fmt.Sprintf("Control[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelSequenceBatching_ControlInputValidationError{
					field:  fmt.Sprintf("Control[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ModelSequenceBatching_ControlInputMultiError(errors)
	}

	return nil
}

// ModelSequenceBatching_ControlInputMultiError is an error wrapping multiple
// validation errors returned by
// ModelSequenceBatching_ControlInput.ValidateAll() if the designated
// constraints aren't met.
type ModelSequenceBatching_ControlInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatching_ControlInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatching_ControlInputMultiError) AllErrors() []error { return m }

// ModelSequenceBatching_ControlInputValidationError is the validation error
// returned by ModelSequenceBatching_ControlInput.Validate if the designated
// constraints aren't met.
type ModelSequenceBatching_ControlInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatching_ControlInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatching_ControlInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatching_ControlInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatching_ControlInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatching_ControlInputValidationError) ErrorName() string {
	return "ModelSequenceBatching_ControlInputValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatching_ControlInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching_ControlInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatching_ControlInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatching_ControlInputValidationError{}

// Validate checks the field values on ModelSequenceBatching_InitialState with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ModelSequenceBatching_InitialState) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching_InitialState
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ModelSequenceBatching_InitialStateMultiError, or nil if none found.
func (m *ModelSequenceBatching_InitialState) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching_InitialState) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataType

	// no validation rules for Name

	switch v := m.StateData.(type) {
	case *ModelSequenceBatching_InitialState_ZeroData:
		if v == nil {
			err := ModelSequenceBatching_InitialStateValidationError{
				field:  "StateData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ZeroData
	case *ModelSequenceBatching_InitialState_DataFile:
		if v == nil {
			err := ModelSequenceBatching_InitialStateValidationError{
				field:  "StateData",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for DataFile
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ModelSequenceBatching_InitialStateMultiError(errors)
	}

	return nil
}

// ModelSequenceBatching_InitialStateMultiError is an error wrapping multiple
// validation errors returned by
// ModelSequenceBatching_InitialState.ValidateAll() if the designated
// constraints aren't met.
type ModelSequenceBatching_InitialStateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatching_InitialStateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatching_InitialStateMultiError) AllErrors() []error { return m }

// ModelSequenceBatching_InitialStateValidationError is the validation error
// returned by ModelSequenceBatching_InitialState.Validate if the designated
// constraints aren't met.
type ModelSequenceBatching_InitialStateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatching_InitialStateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatching_InitialStateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatching_InitialStateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatching_InitialStateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatching_InitialStateValidationError) ErrorName() string {
	return "ModelSequenceBatching_InitialStateValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatching_InitialStateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching_InitialState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatching_InitialStateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatching_InitialStateValidationError{}

// Validate checks the field values on ModelSequenceBatching_State with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelSequenceBatching_State) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching_State with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelSequenceBatching_StateMultiError, or nil if none found.
func (m *ModelSequenceBatching_State) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching_State) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InputName

	// no validation rules for OutputName

	// no validation rules for DataType

	for idx, item := range m.GetInitialState() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModelSequenceBatching_StateValidationError{
						field:  fmt.Sprintf("InitialState[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModelSequenceBatching_StateValidationError{
						field:  fmt.Sprintf("InitialState[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModelSequenceBatching_StateValidationError{
					field:  fmt.Sprintf("InitialState[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ModelSequenceBatching_StateMultiError(errors)
	}

	return nil
}

// ModelSequenceBatching_StateMultiError is an error wrapping multiple
// validation errors returned by ModelSequenceBatching_State.ValidateAll() if
// the designated constraints aren't met.
type ModelSequenceBatching_StateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatching_StateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatching_StateMultiError) AllErrors() []error { return m }

// ModelSequenceBatching_StateValidationError is the validation error returned
// by ModelSequenceBatching_State.Validate if the designated constraints
// aren't met.
type ModelSequenceBatching_StateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatching_StateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatching_StateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatching_StateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatching_StateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatching_StateValidationError) ErrorName() string {
	return "ModelSequenceBatching_StateValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatching_StateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching_State.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatching_StateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatching_StateValidationError{}

// Validate checks the field values on ModelSequenceBatching_StrategyDirect
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ModelSequenceBatching_StrategyDirect) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching_StrategyDirect
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ModelSequenceBatching_StrategyDirectMultiError, or nil if none found.
func (m *ModelSequenceBatching_StrategyDirect) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching_StrategyDirect) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxQueueDelayMicroseconds

	// no validation rules for MinimumSlotUtilization

	if len(errors) > 0 {
		return ModelSequenceBatching_StrategyDirectMultiError(errors)
	}

	return nil
}

// ModelSequenceBatching_StrategyDirectMultiError is an error wrapping multiple
// validation errors returned by
// ModelSequenceBatching_StrategyDirect.ValidateAll() if the designated
// constraints aren't met.
type ModelSequenceBatching_StrategyDirectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatching_StrategyDirectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatching_StrategyDirectMultiError) AllErrors() []error { return m }

// ModelSequenceBatching_StrategyDirectValidationError is the validation error
// returned by ModelSequenceBatching_StrategyDirect.Validate if the designated
// constraints aren't met.
type ModelSequenceBatching_StrategyDirectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatching_StrategyDirectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatching_StrategyDirectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatching_StrategyDirectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatching_StrategyDirectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatching_StrategyDirectValidationError) ErrorName() string {
	return "ModelSequenceBatching_StrategyDirectValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatching_StrategyDirectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching_StrategyDirect.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatching_StrategyDirectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatching_StrategyDirectValidationError{}

// Validate checks the field values on ModelSequenceBatching_StrategyOldest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ModelSequenceBatching_StrategyOldest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelSequenceBatching_StrategyOldest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ModelSequenceBatching_StrategyOldestMultiError, or nil if none found.
func (m *ModelSequenceBatching_StrategyOldest) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelSequenceBatching_StrategyOldest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MaxCandidateSequences

	// no validation rules for MaxQueueDelayMicroseconds

	if len(errors) > 0 {
		return ModelSequenceBatching_StrategyOldestMultiError(errors)
	}

	return nil
}

// ModelSequenceBatching_StrategyOldestMultiError is an error wrapping multiple
// validation errors returned by
// ModelSequenceBatching_StrategyOldest.ValidateAll() if the designated
// constraints aren't met.
type ModelSequenceBatching_StrategyOldestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelSequenceBatching_StrategyOldestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelSequenceBatching_StrategyOldestMultiError) AllErrors() []error { return m }

// ModelSequenceBatching_StrategyOldestValidationError is the validation error
// returned by ModelSequenceBatching_StrategyOldest.Validate if the designated
// constraints aren't met.
type ModelSequenceBatching_StrategyOldestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelSequenceBatching_StrategyOldestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelSequenceBatching_StrategyOldestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelSequenceBatching_StrategyOldestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelSequenceBatching_StrategyOldestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelSequenceBatching_StrategyOldestValidationError) ErrorName() string {
	return "ModelSequenceBatching_StrategyOldestValidationError"
}

// Error satisfies the builtin error interface
func (e ModelSequenceBatching_StrategyOldestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelSequenceBatching_StrategyOldest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelSequenceBatching_StrategyOldestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelSequenceBatching_StrategyOldestValidationError{}

// Validate checks the field values on ModelEnsembling_Step with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelEnsembling_Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelEnsembling_Step with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelEnsembling_StepMultiError, or nil if none found.
func (m *ModelEnsembling_Step) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelEnsembling_Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ModelName

	// no validation rules for ModelVersion

	// no validation rules for InputMap

	// no validation rules for OutputMap

	// no validation rules for ModelNamespace

	if len(errors) > 0 {
		return ModelEnsembling_StepMultiError(errors)
	}

	return nil
}

// ModelEnsembling_StepMultiError is an error wrapping multiple validation
// errors returned by ModelEnsembling_Step.ValidateAll() if the designated
// constraints aren't met.
type ModelEnsembling_StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelEnsembling_StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelEnsembling_StepMultiError) AllErrors() []error { return m }

// ModelEnsembling_StepValidationError is the validation error returned by
// ModelEnsembling_Step.Validate if the designated constraints aren't met.
type ModelEnsembling_StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelEnsembling_StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelEnsembling_StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelEnsembling_StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelEnsembling_StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelEnsembling_StepValidationError) ErrorName() string {
	return "ModelEnsembling_StepValidationError"
}

// Error satisfies the builtin error interface
func (e ModelEnsembling_StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelEnsembling_Step.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelEnsembling_StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelEnsembling_StepValidationError{}

// Validate checks the field values on ModelWarmup_Input with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModelWarmup_Input) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelWarmup_Input with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelWarmup_InputMultiError, or nil if none found.
func (m *ModelWarmup_Input) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelWarmup_Input) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DataType

	switch v := m.InputDataType.(type) {
	case *ModelWarmup_Input_ZeroData:
		if v == nil {
			err := ModelWarmup_InputValidationError{
				field:  "InputDataType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ZeroData
	case *ModelWarmup_Input_RandomData:
		if v == nil {
			err := ModelWarmup_InputValidationError{
				field:  "InputDataType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for RandomData
	case *ModelWarmup_Input_InputDataFile:
		if v == nil {
			err := ModelWarmup_InputValidationError{
				field:  "InputDataType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for InputDataFile
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ModelWarmup_InputMultiError(errors)
	}

	return nil
}

// ModelWarmup_InputMultiError is an error wrapping multiple validation errors
// returned by ModelWarmup_Input.ValidateAll() if the designated constraints
// aren't met.
type ModelWarmup_InputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelWarmup_InputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelWarmup_InputMultiError) AllErrors() []error { return m }

// ModelWarmup_InputValidationError is the validation error returned by
// ModelWarmup_Input.Validate if the designated constraints aren't met.
type ModelWarmup_InputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelWarmup_InputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelWarmup_InputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelWarmup_InputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelWarmup_InputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelWarmup_InputValidationError) ErrorName() string {
	return "ModelWarmup_InputValidationError"
}

// Error satisfies the builtin error interface
func (e ModelWarmup_InputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelWarmup_Input.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelWarmup_InputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelWarmup_InputValidationError{}

// Validate checks the field values on ModelRepositoryAgents_Agent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ModelRepositoryAgents_Agent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModelRepositoryAgents_Agent with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModelRepositoryAgents_AgentMultiError, or nil if none found.
func (m *ModelRepositoryAgents_Agent) ValidateAll() error {
	return m.validate(true)
}

func (m *ModelRepositoryAgents_Agent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Parameters

	if len(errors) > 0 {
		return ModelRepositoryAgents_AgentMultiError(errors)
	}

	return nil
}

// ModelRepositoryAgents_AgentMultiError is an error wrapping multiple
// validation errors returned by ModelRepositoryAgents_Agent.ValidateAll() if
// the designated constraints aren't met.
type ModelRepositoryAgents_AgentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModelRepositoryAgents_AgentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModelRepositoryAgents_AgentMultiError) AllErrors() []error { return m }

// ModelRepositoryAgents_AgentValidationError is the validation error returned
// by ModelRepositoryAgents_Agent.Validate if the designated constraints
// aren't met.
type ModelRepositoryAgents_AgentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModelRepositoryAgents_AgentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModelRepositoryAgents_AgentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModelRepositoryAgents_AgentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModelRepositoryAgents_AgentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModelRepositoryAgents_AgentValidationError) ErrorName() string {
	return "ModelRepositoryAgents_AgentValidationError"
}

// Error satisfies the builtin error interface
func (e ModelRepositoryAgents_AgentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModelRepositoryAgents_Agent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModelRepositoryAgents_AgentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModelRepositoryAgents_AgentValidationError{}
